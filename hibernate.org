#+TITLE: Hibernate ORM



* 基本知识
ORM:
: Object-Relationship Mapping
对象，跟数据库，有着某种对应关系
| 类             | 表的结构(MetaData) |
| 实例化的对象   | 每一条数据         |
| 对象的每个属性 | 数据的每个字段     |

面向对象的封装，让我们在编程的过程中用更自然的思维处理问题，
所以在操作数据库的时候，需要把数据库里的数据跟我们创建的对象关联起来。
我们可以手动写代码实现这个过程。
也可以通过一些 ORM 框架去实现。Hibernate 就是其中一种非常优秀的框架。

* 起步
使用 Hibernate 的步骤:

1. 建立 Web 工程
2. 将需要用到的 jar 包，拷贝到 lib 包的下面。一定不要放错位置。也不要缺少关键包。也尽量不要有包的冲突。
3. 创建 hibernate 的配置文件 hibernate.cfg.xml，指定数据库信息、打印sql语句策略等
   #+BEGIN_SRC xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE hibernate-configuration PUBLIC
   	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
   	"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
   
   <hibernate-configuration>
     <session-factory>
        <!-- 配置数据库的基本信息 -->
        <property name="hibernate.connection.driver_class">oracle.jdbc.driver.OracleDriver</property>
        <property name="hibernate.connection.url">jdbc:oracle:thin:@localhost:1521:orcl</property>
        <property name="hibernate.connection.username">vip</property>
        <property name="hibernate.connection.password">vip</property>
        <property name="hibernate.dialect">org.hibernate.dialect.Oracle10gDialect</property>
        
        <!-- 配置 SQL 语句显示或者 DDL 生成的策略 -->
        <property name="hibernate.show_sql">true</property>
        <property name="hibernate.format_sql">true</property>
        <property name="hibernate.hbm2ddl.auto">create</property>

        <!-- 配置一系列的 Mapping 文件。分为 xml/annotation 等方式 -->        
        <mapping resource="hibernate/helloworld/Book.hbm.xml" />
        <mapping class="hibernate.helloworld.Book" />

     </session-factory>
   </hibernate-configuration>
   #+END_SRC
4. 创建实体类 Book.java
	 #+BEGIN_QUOTE
	 注意，要写成 JavaBean 的规范格式。字段用 private 限制，并为每个字段写 getter/setter 方法(property accessor)。

   还要注意，一个实体类，要跟数据库做映射的话，有一个字段是必须的，就是主键，在 hibernate 中，用 @Id 来表示。

   还要注意，一个实体类，必须要有一个无参构造器。如果我们在里面写了带参数的构造器，那一定不要忘记，增加一个默认的无参构造器。
   #+END_QUOTE

5. 创建数据库跟实体类的映射。有两种方式：XML方式、Annotation方式
   1) 创建相关的xml映射文件 Book.hbm.xml
      #+BEGIN_SRC xml
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE hibernate-mapping PUBLIC 
          "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
           
      <hibernate-mapping>
	      <!-- 配置实体类的映射 -->
      	<class name="hibernate.helloworld.Book" table="t_book">
      		<id name="bookno">
      			<generator class="native"></generator>
      		</id>
      		
      		<property name="name"></property>
      		<property name="price"></property>
      	</class>

	      <!-- 在这里，可以添加其他的实体类映射 -->

      </hibernate-mapping>

      #+END_SRC

   2) 在实体类上加相关的注解
      | @Entity 注解         | 用来标识类是一个与数据库关联的实体类。这个注解作用在类上面。                                                                                                                    |
      | @Id 注解             | 让hibernate把当前属性解析为一个主键                                                                                                                                             |
      | @Basic 注解          | 用来表示，让 hibernate 把当前属性解析为一个表的普通字段。要注意，如果有些java基本类型，没有任何注解的话，默认是带有 @Basic 注解的。                                             |
      | @Table 注解          | 用来自定义生成表的详细信息的。作用在类上面。必须要联合 @Entity 注解一起使用。                                                                                                   |
      | @Column 注解         | 用来自定义生成字段的详细信息的。可选的，配合 @Id 或 @Basic 一起使用。                                                                                                                       |
      | @GeneratedValue 注解 | 用来自定义主键的自动生成策略，如果不带任何参数，那么默认的策略是 AUTO，即让 Hibernate 自动选择生成主键值的方法。这个注解要跟 @Id 一起配合使用。一般情况下，这个也是不可或缺的。 |
      | @Transient 注解      | 用来将指定属性排除掉，不进行持久化                                                                                                                                              |
     
6. 在 hibernate.cfg.xml 中添加映射，开始连接
   1) 创建 sessionFactory
      : 他就是一个大内总管，负责初始化 hibernate，并携带所有的配置信息，而且要负责我们跟数据库打交道的一切杂务。
			#+BEGIN_SRC java
      // 加载配置文件
   		Configuration config = new Configuration().configure( "/hibernate/helloworld/hello.cfg.xml");
      // 初始化所有需要的服务
   		ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(config.getProperties()).build();

			// 在完成 sessionFactory 的创建之前，可以通过 config.addXXX 的方式，动态添加实体类的映射信息
	  	config.addAnnotatedClass(Author.class);
  		config.addResource("hibernate/helloworld/Book.hbm.xml");

      // 创建 sessionFactory 对象
  		SessionFactory sessionFactory = config.buildSessionFactory(serviceRegistry);
			#+END_SRC

   2) 创建 session
   3) 创建 Transaction
   4) 通过 Query 等进行查询；通过 save/delete 等进行增删。
   5) 提交事务，关闭 session，关闭 SessionFactory。



* Load/Get
get 跟 load 的区别如下：
1. 如果查询的数据不存在的话，get 会返回 null；load 会抛出异常。
2. get 是立即从数据库中检索数据； load 是懒加载，即只有当要使用对象的时刻，才进行加载，懒加载是通过代理实现的。


* session.flush()

是让 hibernate 立即执行 sql 语句，但是并不提交，同时更新session缓存。{即同步 session 里的缓存到数据库（插入，更新，删除等）。}

: 只有在调用了 session.flush() 之后，session缓存里的数据，才会被发送到数据库，进行真正的数据库持久化操作。

以下几种清空可以调用 flush:
1. 我们可以在代码中显式调用。在调用的时候，会向数据库中发送操作指令。
   : session.flush();

2. 我们在调用 commit 的时候，也会隐式调用 flush 方法。
   : session.commit();
   commit() 方法，其实就是简单调用了 session.flush() 和 conn.commit()。所以数据会被同步到数据库，而且，事务会提交。

3. 在执行查询的时候，会隐式调用 flush 方法.
   #+BEGIN_SRC java
   @Test
   public void testFlush() {
  		// 更新缓存
  		Author author = new Author();
  		author.setName("struts....");
  		author.setBirth(new Date());
  		
  		// 数据只是存在于 session 的缓存中
  		session.save(author);

      // 从数据库中进行 query 查询的时候，会触发 flush 语句。  		
  		Query query = session.createQuery("from Author");
  		System.out.println(query.list().size());
  		
  		System.out.println("ssss");
  	}
   #+END_SRC


* session.refresh()

在查询的时候，从数据库中更新数据。

所以 refresh 会触发一次查询操作，保证取到的是跟数据库中一致的数据。


* session.clear()

清空整个的 session 缓存内容。


h* Assoc
因为，在数据库中，存在多张表，表根表之间通过外键的形式进行的关联。

但是，在我们的java中，存在的是多个类，类之间是通过互相引用的形式进行沟通。（即一个类中，包含另一个类的引用）。

ORM 的主要是，用面向对象的思维去操作数据库。所以，我们在操作java中的对象，或者修改java中对象之间的关系的时候，ORM 框架能够把我们对对象的修改转换为数据库中表的修改。

所以，我们需要在 java 中设置类之间的相互关系，那么，ORM 框架（hibernate）才能够正确的进行这种转换。

即，hibernate 会根据我们设置的 ManyToOne 等设置，生成正确的表跟表之间的关联。还能够在我们增删改查的时候，根据我们的设置，生成正确的 sql 语句。

所以，不管通过xml还是annotation的形式，你要告诉 hibernate 类之间的关系，他才能在你调用类似 session.save(对象) 的方法时，生成正确的语句并插入数据库。

目前为止，先模仿，后理解。练习越多，越明白。只看不练，空把式。


* ManyToOne
如果一个实体类拥有一个属性，这个属性是另外一个实体类的引用，
那么就不能简单用 @Basic 注解或者 <property /> 标签去定义这个属性跟数据库中表的字段之间的映射关系。
#+BEGIN_SRC java
// 例如，一本书，肯定有一个作者，而 author 属性不是一个简单类型，而是一个对象的引用。
// 书跟作者是一个一对一的关系，也就是一本书，只有一个作者
class Book {
  private Author author;
}
#+END_SRC
在这种情况之下，我们需要用 @ManyToOne 注解 或者用 <many-to-one /> 标签去定义这个属性跟表字段之间的映射。


many-to-one，这个标签的作用是为所在的列，添加一个外键约束。如果不显式指定 column 名字的话，那么默认生成的名字是 属性名_索引的主键名

many-to-one 标签内可以设置 lazy=(false|proxy|no-proxy), fetch=(select|join)。

lazy 通过设置为 false 或其他，定义是否要进行懒加载。如果设置为 false，不会启用懒加载，否则，则会启用懒加载。
懒加载是通过创建代理对象的形式去实现的，所以需要用到字节码编译的技术。
lazy=proxy，那么当设置为懒加载的属性被调用的时候，才会触发查询操作。
lazy=no-proxy，那么当被调用的时候，未必会去查询，只有当调用的语句中使用到数据库里存的数据的时候，才会真正的去数据库查询。
所以，它是加强版的懒加载。lazy=no-proxy需要额外的字节码增强的设置，否则会跟 proxy 一致。

fetch 设置立即加载组织成的查询语句的策略，如果设置为 join，那么会组织成一条 left-join 语句，
如果是 select，那么会组织成若干条独立的查询语句，会查询多次。




* OneToMany
** xml 中的配置
#+BEGIN_SRC xml
<set name="books" cascade="save-update" lazy="extra" fetch="select">
	<key column="authorid"></key>
	<one-to-many class="Book" />
</set>
#+END_SRC

lazy 有下面几个选项： false/true/extra。默认是 true。
- 如果设置为 false，那么立即加载，加载的方式是多条 select 语句。
- 如果设置为 true，会启用懒加载。只有在调用 books 的任何方法时，才会去初始化列表，从而触发从数据库中查询图书列表的请求。
- 如果设置为 extra，也会启用懒加载，但是是更加智能化的懒加载。这时候，如果去调用 books.size() 或 books.contains() 等方法时，并不会真正的初始化图书列表。这样能尽可能节省资源。


fetch 有以下几个选项：
- 如果设置了 select，那么，查询的是多条 select 语句。这是默认值。
- 如果设置了 join，那么 lazy 的设置会无效，会变成立即加载。加载的语句为 left join 方式
- 如果设置了 subselect ....
  #+BEGIN_SRC sql
  -- 如果查询到多条数据，每条数据中都含有一个一对多的关联数据，那么初始化这些关联数据时：
  
  -- 如果设置为 select，那么分别发送一条语句去查询。
  select * from book books0_ where books0_.authorid = 4;
  select * from book books0_ where books0_.authorid = 1;
  -- 可能还有很多很多条
  
  -- 如果设置为 subselect，组织成一条语句去查询。会更加节省资源。
  select *
    from book books0_
   where books0_.authorid in (select author0_.aid from author author0_);
  #+END_SRC




** 注解的形式
#+BEGIN_SRC java
@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.LAZY)
@Fetch(FetchMode.JOIN)
@JoinColumn(name="authorid")
private Set<Book> books = new HashSet<Book>();
#+END_SRC

必须要注明 @JoinColumn，否则，会生成中间表来存储关联关系。 @JoinColumn 是用来订制生成的外键字段的。

通过 cascade 可以设置级联属性；通过 fetch 可以设置是否采用懒加载；通过 @Fetch 注解可以指定查询语句的形式。

注解的形式在某种意义上跟 xml 形式是对应的。


* One.Many.双向
** 在 xml 中配置
#+BEGIN_SRC xml
<set name="books" inverse="true">
	<key column="authorid"></key>
	<one-to-many class="Book" />
</set>

<many-to-one name="author" column="authorid" class="Author"></many-to-one>
#+END_SRC

首先，必须要保证 上面的 column 跟下面的 column 要一致，否则，会在创建表的时候，生成重复的字段，产生不必要的问题。

其次，要在 set 上面配置 inverse="true"，否则，会在生成语句的时候，产生很多很多的冗余。在一对多双向关系中，一般情况下，要在多的一边设置 inverse。

ps：如果设置了 inverse=true，那么会将另一边设为主端，负责关系的维护。
也就是说，当执行 session.save(author) 的时候，不去维护 authorid 的信息；而当执行 session.save(book) 的时候，才去维护 authorid 的信息。
这样，多的一方维护关系，从而减轻了维护成本，提高了效率。（想想习大大跟我们的例子）。

还要注意，在保存的时候，要先保存 1 的一方，否则，会产生很多不必要的 update 语句，从而影响效率。


** 通过注解的方式进行配置
在双边分别这样配置：
#+BEGIN_SRC java
// @JoinColumn(name="authorid") 这个不需要去写，因为 mappedBy 会默认触发外键操作
@OneToMany(mappedBy="author")   // author 对应的是 book 里面的 author 属性
private Set<Book> books = new HashSet<Book>();


@ManyToOne
@JoinColumn(name="authorid")
private Author author;
#+END_SRC

首先，上边跟下边的 JoinColumn 值的名字，需要一致

其次，要在 @OneToMany 里面设置 mappedBy 属性，将双方关系的控制权交给另外一边。

最后，保存的时候，注意顺序，要先保存 1 的一边。



* Cascade
级联。
在利用 hibernate 对实体类对象进行持久化(如 session.save)的时候，需要保证里面引用的对象已经处于持久化状态。

否则，会出现以下异常
: org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance before flushing: hibernate.assoc.many2one.Author

解决方案有以下两种：
1. 在保存对象前，对所有引用到的对象先执行持久化操作。
2. 在实体类中，为这些引用到的对象，设置合适的级联属性。这样的话，hibernate 会在保存对象的时候，自动将引用到的还没有持久化的对象进行持久化。

级联可以通过注解的形式进行配置，也可以通过 XML 的形式进行配置。
: @ManyToOne(cascade=CascadeType.PERSIST)
: <many-to-one cascade="save-update" />

大抵有如下几种：
: none：在保存，删除或修改当前对象时，不对其附属对象（关联对象）进行级联操作，它是默认值。 
: save-update：在保存，更新当前对象时，级联保存，更新附属对象（临时对象、游离对象）。 
: delete：在删除当前对象时，级联删除附属对象。 
: all：所有情况下均进行级联操作，即包含 save-update 和 delete 操作


在我们的开发环境中，设置好 cascade 会让我们的代码更整洁，测试更方便。但是，在工业环境中，不建议使用任何 cascade 设置。

* Fetch
注解配置，有两种 FetchType.EAGER/FetchType.Lazy，分别对应立即加载和惰性加载。

* Roll
6. query 对象, hql
3. Many to one 关系。包括配置，使用
9. One to Many 关系。包括配置，使用





* 改写 hello，增加 hibernate 支持
* Java 提高


** 日期与时间
*** Date 类
这是 java 最开始就有的类，用来处理时间。
#+BEGIN_SRC java
// 获取当前时间
Date now = new Date();
// 打印时间，显式格式为 Thu Nov 03 16:31:56 CST 2016
System.out.println(now);
// 获取时间中的年、月、日等
System.out.println(now.getYear()); // 注意，这样得到的是一个减去了 1990 的年份。
// 得到从 1970 年到现在经过的毫秒数
System.out.println(now.getTime());
// 所以得到两个时间相差多少一般这样表示
long duration = date1.getTime() - date2.getTime();

// 得到指定日期的时间
Date time1 = new Date(12212221);
Date time2 = new Date("19900202");
Date time3 = new Date(1990, 1, 14);  // 注意，月份从0开始计算。1这条语句表示 1990年2月14日
// 通过 SimpleDateFormat 的形式得到指定格式的日期
Date time4 = new SimpleDateFormat("yyyyMMdd").parse("20050205");

#+END_SRC

*** Calendar 类

后来由于 Date 类在处理国际化方面的一些局限，现在推荐用 Calendar 类代替 Date 类。
#+BEGIN_SRC java
// 获取当前时间
Calendar c = Calendar.getInstance();
// 通过 getTime 获得 Date 对象。通过下面语句，打印当前时间
System.out.println(c.getTime());
// 通过下面语句，获取年月日等
System.out.println(c.get(Calendar.YEAR));

// 通过下面语句，初始化一个具体时间
c.set(1999, 2, 4);
// 或者通过时间类型得到
c.setTime(new Date());
// 或者，通过直接实例化一个 Calendar 的实现类：
Calendar cc = new GregorianCalendar(1998,3,11);
// 下面语句得到 1970 年来的 long 值
System.out.println(cc.getTimeInMillis);

#+END_SRC


*** 其它

通过以上代码看以看到，通过 calendar.setTime()/getTime() 方法可以实现 Date/Calendar 对象的转换。

另外，为了方便， System 下面有个静态方法，也可以获取 1970 年到现在过了多少毫秒，返回时 long 值：、
: System.currentTimeMillis();
这个非常常用。



** getter 代码，实现更好的封装

#+BEGIN_SRC java
@Test
public void testGetterDate() throws Exception {
	Author author = new Author();
	author.setName("张三");
	author.setBirth(new SimpleDateFormat("yyyy-MM-dd").parse("1993-04-14"));
	
	System.out.println("用户创建成功。");
	
	// 接下来获取年龄，有如下方式：

	// 第一种写法：
	System.out.println("1. 年龄：" + (new Date().getYear() - author.getBirth().getYear()));

	// 第二种方法，创建一个静态方法，通过调用，获取年龄：
	System.out.println("2. 年龄：" + BirthUtil.calAge(author.getBirth()));

	// 第三种，在 author 类中，增加年龄字段。因为年龄也是人的一个属性。
	// 这样能更好的体现面向对象的思想：封装。
	// 因为年龄跟生日有关系，所以不需要显式赋值，如果想获取，那么通过下面的方式：
	System.out.println("3. 年龄：" + author.getAge());
}


// 在 getter 方法中，可以写一些具体的逻辑。
// 这里通过生日的字段，计算年龄。当调用这个 getter 方法的时候，才开始计算。
// 而年龄这个值，不需要保存到数据库中。所以上面需要增加一个 @Transient 注解，将其排出在外。
// 这种处理方式，是非常常见的。尤其在 getter/setter 方法中，添加自己的逻辑，有时候，会使代码变得便捷。
class Author {
  private int age;
  // ... others
  public int getAge() {
		return age == 0 ? BirthUtil.calAge(birth) : age;
  }
}


// 根据生日计算年龄的静态方法
class BirthUtil {
	public static int calAge(Date birth) {
  	Calendar cal = Calendar.getInstance();
  	int now = cal.get(Calendar.YEAR);
  	cal.setTime(birth);
  	return now - cal.get(Calendar.YEAR);
	}
}

#+END_SRC
