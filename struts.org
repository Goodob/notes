#+TITLEE: Struts2


* Preclue

Tomcat 编译 jsp 到 java 文件的保存目录：
: E:\workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\work\Catalina\localhost\hello\org\apache\jsp\WEB_002dINF\login

* 框架
框架是一个半成品。它提供了一些接口、类、方法，我们可以直接调用。

所以使用框架，相当于在别人开发了一半的项目上继续开发。

因此，框架有以下优势：
1. 能提高我们的开发效率。
2. 能大幅度减少我们的代码量。
3. 能提高代码的健壮性。比如，jquery的跨浏览器问题。


* 简介

Struts2 是一个流行的 MVC 框架。

官方网站：https://struts.apache.org/


导入 struts-blank 项目有两种方式： maven 方式和一般方式。下面介绍一般的方式：
1. 在 eclipse 中，选择新建一个 dynamic web project，例如名字为 ls02.
2. 将 src/apps/blank/src/main/java 下的文件复制到 workspace/ls02/src 文件夹下。
3. 将 src/apps/blank/src/main/resources 下的文件复制到 workspace/ls02/src 文件夹下。
4. 将 src/apps/blank/src/main/webapp 下的文件复制到 workspace/ls02/WebContent 文件夹下。
5. 将相关的 jar 包放到 workspace/ls02/WebContent/WEB-INF/lib 文件夹下。

需要的jar包有以下：
- asm-3.3.jar
- asm-commons-3.3.jar
- asm-tree-3.3.jar
- commons-fileupload-1.3.2.jar
- commons-io-2.2.jar
- commons-lang3-3.2.jar
- hamcrest-core-1.3.jar
- javassist-3.11.0.GA.jar
- javax.servlet-api-3.1.0.jar
- javax.servlet.jsp-api-2.3.1.jar
- jstl-1.2.jar
- junit-4.12.jar
- log4j-1.2.17.jar
- ognl-3.0.19.jar
- ojdbc7.jar
- struts2-core-2.3.30.jar
- struts2-json-plugin-2.3.30.jar
- xwork-core-2.3.30.jar

* 示例（注册登录）
** 业务分析
我们需要以下四个请求：、
1. 第一个请求：\\
   显示登录的页面。  login.jsp

2. 第二个请求：\\
   点击登录之后，要完成登录的操作。
   welcome.jsp
   fail.jsp

3. 第三个请求：\\
   显示注册的页面。
   regist.jsp

4. 第四个请求：\\
   点击“注册”按钮之后，完成注册的操作。
   login.jsp
   regerror.jsp

** 实现步骤：
1. *建立动态web项目。*
  
   打开 eclipse，选择 File -> New -> Dynamic Web Project(快捷键为Ctrl-N)。

   注意，工程名字尽量简洁，尽量用小写字母和_的组合。

   注意，在创建的工程的时候，将创建 web.xml 的选项勾上。
   因为在 servlet3 版本中，可以不需要 web.xml 的情况下运行 web 工程，但是我们要使用 struts2，必须要在 web.xml 中进行若干的配置。

2. *将相关的 jar 包，复制到 工程目录/WebContent/WEB-INF/lib 文件夹下面。*

   注意，一定不要缺少某些关键包，否则可能会报错。

   注意，如果出现一些莫名其妙的问题，包括像报 ClassNotFound 的异常，这时候，首先要检查是否有 jar 包的缺失。

3. *配置 web.xml，将所有的请求交给 struts 进行处理。*

   即在 web.xml 中添加以下内容：
   #+BEGIN_SRC xml
   <filter>
       <filter-name>struts</filter-name>
       <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
   </filter>
   <filter-mapping>
       <filter-name>struts</filter-name>
       <url-pattern>/*</url-pattern>
   </filter-mapping>
   #+END_SRC

   注意： filter-name 是可以随意定义的，不过上下两个节点要填写一致，不要搞错。

   注意： 要确保 filter-class 的值写正确，这是一个确切存在的过滤器类。可以通过查看 struts2-core.jar 的源码去确定。

   注意： 在 elipse 左边的 Web App Libraries 下面，找到 struts2-core.jar，打开节点，直到 StrutsPrepareAndExecuteFilter，然后右键点击，选择 Copy Qualified Name，这样就把这个过滤器的完整路径复制下来了。然后就可以在 web.xml 中进行粘贴了。

   注意： 如果创建完工程之后，发现没有 web.xml，那么你需要自己创建或者从其他地方拷贝一个 web.xml 过来。但是注意，一定不要讲文件放错位置（WebContent/WEB-INF/web.xml）。而且，要注意 xml 中头部务必要写正确， xml 的格式也不能出现问题。
   
   注意： 以前的老旧版本中，使用的是过滤器 org.apache.struts2.dispatcher.FilterDispatcher。但现在已经被抛弃，不要使用，而是用 StrutsPrepareAndExecuteFilte代替。

4. *创建文件 struts.xml，配置所有模块和请求，即配置相应的 package 和 action。*

   这是 struts 的配置中心，所有的 struts 属性配置和请求映射，都在这个文件夹中进行action设置。

   需要将这个文件放在 classpath 的根目录下面。我们可以理解，我们需要在 工程目录/src 文件夹下面创建这个文件。

   如果我们创建的工程能够运行起来不报错，但是我们的 action 请求返回404错误的话，首先需要检查我们的请求有没有写错，如果没有写错，那么，就要检查是不是我们的 struts.xml 放错了位置或写错了名字。

   如果我们的工程能够运行，但是在请求的时候，返回一些比如 result 没有正确映射等错误，那么，我们就需要检查是不是在 struts.xml 中配置错了东西。

   struts.xml，最好我们备份一份，在创建的时候，直接拷贝。因为，这个文件的格式，尤其是头部：
   #+BEGIN_SRC xml
   <?xml version="1.0" encoding="UTF-8" ?>
   <!DOCTYPE struts PUBLIC
   	"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"
   	"http://struts.apache.org/dtds/struts-2.3.dtd">
   
   <struts>
      <package></package>
   </struts>

   #+END_SRC
   头部的 dtd 文件可以在 struts2-core.jar 的根目录之下找到。里面可以拷贝到 DOCTYPE 的定义。

   注意， *一个请求对应一个 action* 。这个概念务必要理解。另外，一个业务模块定义在一个 package 中，这个也要掌握。

   我们可以使用通配符来简化 action 配置。但务必不要滥用通配符，尤其刚开始的时候不建议过多使用通配符。

5. *实现相应的 jsp*

   一些比较敏感的，尤其是涉及权限的东西，我们最好放在 WEB-INF 目录下面，因为按照 j2ee 的规范， WEB-INF 目录下的内容，不能够由外部直接访问，所以能够最大限度保证安全。

   那我们也要养成一种习惯，把主要的业务操作方面的 jsp 放在 WEB-INF 下面，一些其他的通用的不重要的资源可以放在 WEB-INF 外面。

6. *实现相应的 action*
   
   Action 中的每个执行业务的方法，只有一个要求，不携带参数并返回 String 类型。而一个 action 就是一个普通的 java 对象。不过为了方便，绝大多数时候我们要为我们自己定义的 Action 继承 ActionSupport 类。

   需要注意，必须要养成良好的编程习惯。习惯成自然，不要让不好的习惯带给我们一些莫名其妙的损失。

   下面是一些基本的规范：
   - 我们写类跟接口之前，必须要定义一个相对完整的包。尤其忌讳把所有的东西都放在 classpath 的跟路径之下。
   - 包的名字要有相应的意义，不同种类的类或接口要放在不同的包中，不要混乱地放在一起。
   - 包的名字，务必要用小写字母。
   - 类或接口的名字，务必务必要用大写字母开头，而且要写成驼峰格式。
   - 里面的方法也要写成驼峰形式。
   - 格式要对齐，文件中要么都是用 tab，要么都使用空格，不建议混用，否则，可能在别人的电脑上，会出现代码对不齐的现象。
   - 等号等操作符的前面和后面，要带有空格，便于阅读。

* Package

在 struts.xml 中首先需要定义 package，package 我们可以理解为一个业务模块。

一个系统有多个功能，即有多个业务模块，表现在 struts.xml 中就是有多个 package。一个业务模块需要请求很多页面，相应一个 package 包含多个 action.

注意：必须要有模块化的概念，为业务创建相关的 package 和 namespace，这样便于管理维护，也便于功能的扩展。

定义 package 需要给予一个名字，还可以设置命名空间（默认为 / ）和父包。

我们自定义的 package 最好继承 struts-default 包，它定义在 struts-default.xml 中（可以展开 struts2-core.jar 看到）。这个 package 内置了一些 result 类型，一些拦截器，并配置了一些常见的 struts 常量。我们可以直接使用。

Package 主要由 action 构成，除此之外，还可以声明拦截器，配置包范围的异常处理，定义包范围的 result。

* Action
action 必须要有的属性是 name，这个定义了这个 action 的唯一标识。 class如果不指定的话，那么默认是 ActionSupport 类。 method 不指定的话，默认是 execute 方法。

action 至少要有一个节点，就是 result。如果 result 不去指定 name 的话，那么它的默认名字就是 success.

action 下面可以定义一到多个异常处理节点，用来捕获本次请求出现的指定异常。
: <exception-mapping result="fail" exception="java.lang.Exception"></exception-mapping>

如果请求的过程中，出现异常，那么 struts 首先判断当前 action 节点下面有没有配置相关的 exception-mapping 节点，如果有并且异常匹配，那么页面会转到本异常处理节点指定的页面。

如果 action 节点下面没有配置相关的 exception-mapping，那么 struts 会到当前包下面搜索，有没有配置 global-exception-mapping 节点。如果有配置，那么，就会根据所匹配的异常处理，进行返回结果。

如果 action 节点下面没有配置，而且包下面没有配置，那么，就不会有相应的异常处理。服务器会把一个 404 等相关的错误页面直接打印给用户。（这样首先不美观，不专业，其次，非常不安全。）

异常处理，可以在当前 action 节点下面配置。相应的，可以在 package 下面配置全局的异常处理。
: <global-exception-mappings>
:   <exception-mapping result="fail" exception="java.lang.Exception"></exception-mapping>
: </global-exception-mappings>

返回结果，即 result，同样，我们需要在当前 action 下面配置。相应，可以在 package 下面配置全局的结果返回。
: <global-results>
: 	<result name="fail">/WEB-INF/login/login.jsp</result>
: </global-results>


Action 类的典型示例如下，很简单：

#+BEGIN_SRC java
public Class LoginAction () {
    private String name;
    private int age;
    
    public String execute () {
        System.out.println("名字是:" + name + "    年龄为:" + age);
        return "success";
    }

    // setter...
    // setter...
}

#+END_SRC


* Result
如果不指定名字，那么默认的名字就是 success, 如果不指定 type，默认的 type 就是 dispatcher。我们常用的就是一下几个。
** dispatcher/redirect
转发或者重定向，一般用于 jsp
#+BEGIN_SRC xml
<result type="redirect" name="fail">/WEB-INF/jsp/login/fail.jsp</result>
#+END_SRC

如果 result 不指定类型的话，那么默认为 dispatcher.

** chain/redirectAction
转发或者重定向 xxx.action，用于一个新的 struts 请求。

如果要转发到另外一个包下的连接的话：
#+BEGIN_SRC xml
<result name="success" type="chain">
	<param name="namespace">/emp</param>
	<param name="actionName">listAll</param>
</result>
#+END_SRC

如果要重定向到另外一个包下面的请求的话，有下面两种写法：
#+BEGIN_SRC xml
<!-- 下面两种写法是等效的 -->
<result type="redirectAction">
	<param name="namespace">/emp</param>
	<param name="actionName">listAll</param>
</result>

<result type="redirect">/emp/listAll.html</result>
#+END_SRC

** stream
是用来处理 struts 中文件的上传和下载的。






   

* 流程
1. 请求发送给 StrutsPrepareAndExecuteFilter
2. StrutsPrepareAndExecuteFilter 询问 ActionMapper：请求是不是一个 Action(是的话返回非空的 ActionMapping)
3. 如果请求是一个 Action，则把请求交给 ActionProxy 对象处理。
4. ActionProxy 中，通过 ConfigurationManager 加载配置文件，得到处理请求的 Action 类和方法。
5. ActionProxy 创建一个 ActionInvocation 实例并初始化。
6. ActionInvocation 负责调用 Action，在调用的前后，需要执行 Interceptor 链。在调用完 Action 后要执行 result 的结果。
7. 把结果发送到客户端。

* 拦截器
所有实现了 Interceptor 接口的类，都叫拦截器。
在 Struts 中，是利用拦截器进行功能实现的，比如值的自动封装，类型的转换，值栈的维护，验证，国际化等方面。
每一个拦截器都实现用来完成单一的功能。多个拦截器，按照顺序放在一个列表中，按照顺序执行，可以达到完成一系列功能的目的。
这多个的拦截器放在一起，又称为拦截器栈（栈是一种非常基本的数据结构，它遵守先进后出的原则。简单理解，它是有顺序的一个列表）。

比如，在 struts 中，对值进行自动封装的拦截器叫 ParameterFilterInterceptor；对异常处理的拦截器叫 ExceptionMappingInterceptor，其他所有功能，在 struts 中都有相应的拦截器实现。

所以，在一个请求发起，经 struts 进行处理，程序流程在到达 action 相关的处理方法之前，会按照配置经过多个拦截器，从而实现一定的功能，比如，值的封装:
: 拦截器a -> 拦截器 B -> 拦截器 C -> 拦截器 D ... -> Action.Method -> 后续的一些处理，包括返回显示页面等。

在 struts.xml 中，需要为每个 action 设置拦截器，用来实现完整功能。
当然，如果我们不对 action 设置 interceptor-ref 节点，即不设置拦截器，那么如果我们的包继承了 struts-default，那么任何一个包内的 action，会默认使用 defaultStack 拦截器。它其实是一个拦截器栈，即是一系列的拦截器的一个列表。

** 原理
** 定义
** 示例
* 自动封装(Autowired)
* 值栈
EL(Expression Language) 是为了分离页面跟代码，避免JSP中糅杂太多<% %>而出现的。\\

它有如下好处：
- 避免复杂的java代码，使页面简单整洁
- 支持运算符，自由强大高效
- 有简单的逻辑控制，易于阅读和维护

Struts2 支持的 EL 语言有：
1. OGNL (Object-Graph Navigation Language) // Struts 默认
2. JSTL (JSP Standard Tag Library)                 // JSP2.0集成
3. Groovy
4. Velocity，只是一个简单的模板匹配引擎啦

Expression, Root, Context. getValue. setValue.


值栈是 struts 进行数据传递的中心，它是 struts 运行过程中创建的一个对象。本质上它是保存在 request 对象上的一个 attribute.

在 Struts 中，值栈（ValueStack）分为两个逻辑部分
1. 对象栈

   它其实是 Map 栈中的一个值。是作为一个默认的存在。本质上它是一个 ArrayList， Struts 在接受到一个请求的时候，会把创建的 Action 对象保存到这个 ArrayList 中。

2. Map栈
   
   本质上就是一个 Map，它是对 ActionContent 的引用。Struts 把一些常用的映射关系（比如，session,application,parameters等）保存到了这个对象中。
   
   Map 栈的大致结构如下:


在 jsp 页面中，如果打开了 devMove 模式，那么可以通过 <s:debug /> 查看整个值栈中保存的数据。


** 在 jsp 中获取值栈的值
首先，可以使用 <s:property /> 标签，通过在 value 属性里面的 ognl 表达式，就可以取到值栈中对应的值了。

ognl 表达式的语法规则为：
: #key.a.b.c

当然，如果我们要获取的值，是属于 OgnlContext 的 Root 对象，那么，前面的 #key 可以去掉。

因此，如果我们在 Action 里面定义了变量（比如，price），并赋予了值，那么，到 jsp 页面中，我们就可以直接用下面语句取出它的值：
: <s:property value="price" />

如果，我们要显示的值，是一个集合，比如，list，那么我们可以用 <s:iterator /> 标签循环取出它里面的值。
#+BEGIN_SRC java
<s:iterator var="j" value="emps">
	<tr>
		<td>${name}</td>
		<td><s:property value="job"/></td>
		<td><s:property value="#j.sal"/></td>
		<td><a href="delete.html?ename=${name}">删除</a></td>
	</tr>
</s:iterator>
#+END_SRC


注意，因为 struts 中对 request 对象进行了封装，并且重载了它的 getAttribute 方法，使得可以通过 getAttribute 方法直接从值栈对象中获取值。
所以，如果我们在 jsp 页面中，使用el表达式，可以达到跟使用 <s:property /> 标签同样的效果。


** 在 action 类中，获取 session 等对象的方法
在 action 中，向 session 中加入值，有如下几张方法：
#+BEGIN_SRC java
// 第一种，从 ServletActionContext提供的静态方法获取。
// 比如，ServletActionContext.getRequest() 得到的是一个原生的 HttpServletRequest 对象。得到后我们可以按照以前写 servlet 时候的写法处理这个对象。
// 所以，如果想得到回话对象的话，那么如下代码：
HttpSession s1 = ServletActionContext.getRequest().getSession();
s1.setAttribute("flag1", "red");

// struts 提供了另外一种封装，即把 session,request 等当做 Map 对象来处理，达到简化我们操作的目的。
Map<String, Object> s2 = ActionContext.getContext().getSession();
s2.put("flag2", "green");

// 通过实现 SessionAware 接口，定义全局的 session 对象。
// 首先要定义全局的 Map<String, Object> s3 = null; 然后实现 SessionAware 接口。
s3.put("flag3", "yellow");

#+END_SRC

在 jsp 页面中，这样使用session中的值。
: <s:property value="#session.flag" />





* 标签库
* 验证
调用的 xwork 中的验证配置
1. 声明式验证
   : ActionName[-Alias]-validation.xml
2. 编程式验证
   : @Override public void validate () {}



* 类型转换
struts 会自动进行类型转换。但一些复杂的对象，自动转换会满足不了我们的需求，这时候需要自定义类型转换器
1. 创建转换器。必须要实现 ognl.TypeConverter 接口。实际上继承 StrutsTypeConverter 即可。
2. 基于字段，model/ModelClassName-conversion.properties。基于类型，src/xwork-conversion.properties
    : java.util.Date=你定义的类型转换器


* 国际化
* 文件的上传下载
* 防止重复提交
三种情况：
1. 多次点击
2. 回退，再提交
2. 转发时 F5 刷新

解决方案： token 拦截器/ tokenSession 拦截器
1. 在配置文件中添加 token 拦截器，它不包含在默认拦截器栈中。
2. 添加标签 <s:token />，会在页面生成一个隐藏域并在session赋值，两个一致。
3. 若使用 token 拦截器，需要配置一个 token.valid 的 result，因为它要跳往错误页面
4. tokenSession 则不用配置 result。页面不会动。tokenSession 拦截器不会执行后续拦截器。

* ajax
