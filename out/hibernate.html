<!DOCTYPE html>
<html>
<head>
<title>Hibernate</title>
<!-- 2017-03-15 周三 16:38 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="imfine">
<link rel="stylesheet" href="nnn.css">
<meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Hibernate</h1>
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 基本知识</a></li>
<li><a href="#sec-2">2. 起步</a></li>
<li><a href="#sec-3">3. Load/Get</a></li>
<li><a href="#sec-4">4. Session 操作</a>
<ul>
<li><a href="#sec-4-1">4.1. session.flush()</a></li>
<li><a href="#sec-4-2">4.2. session.refresh()</a></li>
<li><a href="#sec-4-3">4.3. session.clear()</a></li>
</ul>
</li>
<li><a href="#sec-5">5. 关联映射(Assoc)</a>
<ul>
<li><a href="#sec-5-1">5.1. 一对一（主键关联）</a></li>
<li><a href="#sec-5-2">5.2. 一对一（外键关联）</a></li>
<li><a href="#sec-5-3">5.3. 多对一（单向）</a></li>
<li><a href="#sec-5-4">5.4. 一对多（单向）</a></li>
<li><a href="#sec-5-5">5.5. 一对多（双向）</a></li>
<li><a href="#sec-5-6">5.6. 多对多（双向）</a></li>
</ul>
</li>
<li><a href="#sec-6">6. 继承(Inheritance)</a>
<ul>
<li><a href="#sec-6-1">6.1. subclass</a></li>
<li><a href="#sec-6-2">6.2. joined-class</a></li>
<li><a href="#sec-6-3">6.3. union-subclass</a></li>
</ul>
</li>
<li><a href="#sec-7">7. 级联（Cascade）</a></li>
<li><a href="#sec-8">8. 检索策略</a></li>
<li><a href="#sec-9">9. 检索方式</a>
<ul>
<li><a href="#sec-9-1">9.1. HQL</a></li>
<li><a href="#sec-9-2">9.2. QBC</a></li>
<li><a href="#sec-9-3">9.3. SQLQuery</a></li>
</ul>
</li>
<li><a href="#sec-10">10. 二级缓存</a></li>
<li><a href="#sec-11">11. 乐观锁、悲观锁</a></li>
</ul>
</div>
</nav>


<section id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 基本知识</h2>
<div class="outline-text-2" id="text-1">
<p>
ORM:
</p>
<pre class="example">
Object-Relationship Mapping
</pre>
<p>
对象，跟数据库，有着某种对应关系
</p>
<table>


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="left">类</td>
<td class="left">表的结构(MetaData)</td>
</tr>

<tr>
<td class="left">实例化的对象</td>
<td class="left">每一条数据</td>
</tr>

<tr>
<td class="left">对象的每个属性</td>
<td class="left">数据的每个字段</td>
</tr>
</tbody>
</table>

<p>
面向对象的封装，让我们在编程的过程中用更自然的思维处理问题，
所以在操作数据库的时候，需要把数据库里的数据跟我们创建的对象关联起来。
我们可以手动写代码实现这个过程。
也可以通过一些 ORM 框架去实现。Hibernate 就是其中一种非常优秀的框架。
</p>
</div>
</section>

<section id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 起步</h2>
<div class="outline-text-2" id="text-2">
<p>
使用 Hibernate 的步骤:
</p>

<ol class="org-ol">
<li>建立 Web 工程
</li>
<li>将需要用到的 jar 包，拷贝到 lib 包的下面。一定不要放错位置。也不要缺少关键包。也尽量不要有包的冲突。
</li>
<li>创建 hibernate 的配置文件 hibernate.cfg.xml，指定数据库信息、打印sql语句策略等
<div class="org-src-container">

<pre class="src src-xml">&lt;?<span style="color: #a020f0;">xml</span> <span style="color: #a0522d;">version</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">1.0</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">encoding</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">UTF-8</span><span style="color: #8b2252;">"</span>?&gt;
&lt;!<span style="color: #a020f0;">DOCTYPE</span> hibernate-configuration <span style="color: #a020f0;">PUBLIC</span>
 <span style="color: #8b2252;">"</span><span style="color: #8b2252;">-//Hibernate/Hibernate Configuration DTD 3.0//EN</span><span style="color: #8b2252;">"</span>
 <span style="color: #8b2252;">"</span><span style="color: #8b2252;">http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd</span><span style="color: #8b2252;">"</span>&gt;

&lt;<span style="color: #0000ff;">hibernate-configuration</span>&gt;
  &lt;<span style="color: #0000ff;">session-factory</span>&gt;
     <span style="color: #b22222;">&lt;!--</span><span style="color: #b22222;"> &#37197;&#32622;&#25968;&#25454;&#24211;&#30340;&#22522;&#26412;&#20449;&#24687; </span><span style="color: #b22222;">--&gt;</span>
     &lt;<span style="color: #0000ff;">property</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate.connection.driver_class</span><span style="color: #8b2252;">"</span>&gt;oracle.jdbc.driver.OracleDriver&lt;/<span style="color: #0000ff;">property</span>&gt;
     &lt;<span style="color: #0000ff;">property</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate.connection.url</span><span style="color: #8b2252;">"</span>&gt;jdbc:oracle:thin:@localhost:1521:orcl&lt;/<span style="color: #0000ff;">property</span>&gt;
     &lt;<span style="color: #0000ff;">property</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate.connection.username</span><span style="color: #8b2252;">"</span>&gt;vip&lt;/<span style="color: #0000ff;">property</span>&gt;
     &lt;<span style="color: #0000ff;">property</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate.connection.password</span><span style="color: #8b2252;">"</span>&gt;vip&lt;/<span style="color: #0000ff;">property</span>&gt;
     &lt;<span style="color: #0000ff;">property</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate.dialect</span><span style="color: #8b2252;">"</span>&gt;org.hibernate.dialect.Oracle10gDialect&lt;/<span style="color: #0000ff;">property</span>&gt;

     <span style="color: #b22222;">&lt;!--</span><span style="color: #b22222;"> &#37197;&#32622; SQL &#35821;&#21477;&#26174;&#31034;&#25110;&#32773; DDL &#29983;&#25104;&#30340;&#31574;&#30053; </span><span style="color: #b22222;">--&gt;</span>
     &lt;<span style="color: #0000ff;">property</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate.show_sql</span><span style="color: #8b2252;">"</span>&gt;true&lt;/<span style="color: #0000ff;">property</span>&gt;
     &lt;<span style="color: #0000ff;">property</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate.format_sql</span><span style="color: #8b2252;">"</span>&gt;true&lt;/<span style="color: #0000ff;">property</span>&gt;
     &lt;<span style="color: #0000ff;">property</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate.hbm2ddl.auto</span><span style="color: #8b2252;">"</span>&gt;create&lt;/<span style="color: #0000ff;">property</span>&gt;

     <span style="color: #b22222;">&lt;!--</span><span style="color: #b22222;"> &#37197;&#32622;&#19968;&#31995;&#21015;&#30340; Mapping &#25991;&#20214;&#12290;&#20998;&#20026; xml/annotation &#31561;&#26041;&#24335; </span><span style="color: #b22222;">--&gt;</span>        
     &lt;<span style="color: #0000ff;">mapping</span> <span style="color: #a0522d;">resource</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate/helloworld/Book.hbm.xml</span><span style="color: #8b2252;">"</span> /&gt;
     &lt;<span style="color: #0000ff;">mapping</span> <span style="color: #a0522d;">class</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate.helloworld.Book</span><span style="color: #8b2252;">"</span> /&gt;

  &lt;/<span style="color: #0000ff;">session-factory</span>&gt;
&lt;/<span style="color: #0000ff;">hibernate-configuration</span>&gt;
</pre>
</div>
</li>
<li>创建实体类 Book.java
<blockquote>
<p>
注意，要写成 JavaBean 的规范格式。字段用 private 限制，并为每个字段写 getter/setter 方法(property accessor)。
</p>

<p>
还要注意，一个实体类，要跟数据库做映射的话，有一个字段是必须的，就是主键，在 hibernate 中，用 @Id 来表示。
</p>

<p>
还要注意，一个实体类，必须要有一个无参构造器。如果我们在里面写了带参数的构造器，那一定不要忘记，增加一个默认的无参构造器。
</p>
</blockquote>
</li>

<li>创建数据库跟实体类的映射。有两种方式：XML方式、Annotation方式
<ol class="org-ol">
<li>创建相关的xml映射文件 Book.hbm.xml
<div class="org-src-container">

<pre class="src src-xml">&lt;?<span style="color: #a020f0;">xml</span> <span style="color: #a0522d;">version</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">1.0</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">encoding</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">UTF-8</span><span style="color: #8b2252;">"</span>?&gt;
&lt;!<span style="color: #a020f0;">DOCTYPE</span> hibernate-mapping <span style="color: #a020f0;">PUBLIC</span> 
    <span style="color: #8b2252;">"</span><span style="color: #8b2252;">-//Hibernate/Hibernate Mapping DTD 3.0//EN</span><span style="color: #8b2252;">"</span>
    <span style="color: #8b2252;">"</span><span style="color: #8b2252;">http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd</span><span style="color: #8b2252;">"</span>&gt;

&lt;<span style="color: #0000ff;">hibernate-mapping</span>&gt;
    <span style="color: #b22222;">&lt;!--</span><span style="color: #b22222;"> &#37197;&#32622;&#23454;&#20307;&#31867;&#30340;&#26144;&#23556; </span><span style="color: #b22222;">--&gt;</span>
  &lt;<span style="color: #0000ff;">class</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate.helloworld.Book</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">table</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">t_book</span><span style="color: #8b2252;">"</span>&gt;
      &lt;<span style="color: #0000ff;">id</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">bookno</span><span style="color: #8b2252;">"</span>&gt;
          &lt;<span style="color: #0000ff;">generator</span> <span style="color: #a0522d;">class</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">native</span><span style="color: #8b2252;">"</span>&gt;&lt;/<span style="color: #0000ff;">generator</span>&gt;
      &lt;/<span style="color: #0000ff;">id</span>&gt;

      &lt;<span style="color: #0000ff;">property</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">name</span><span style="color: #8b2252;">"</span>&gt;&lt;/<span style="color: #0000ff;">property</span>&gt;
      &lt;<span style="color: #0000ff;">property</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">price</span><span style="color: #8b2252;">"</span>&gt;&lt;/<span style="color: #0000ff;">property</span>&gt;
  &lt;/<span style="color: #0000ff;">class</span>&gt;

    <span style="color: #b22222;">&lt;!--</span><span style="color: #b22222;"> &#22312;&#36825;&#37324;&#65292;&#21487;&#20197;&#28155;&#21152;&#20854;&#20182;&#30340;&#23454;&#20307;&#31867;&#26144;&#23556; </span><span style="color: #b22222;">--&gt;</span>

&lt;/<span style="color: #0000ff;">hibernate-mapping</span>&gt;
</pre>
</div>
</li>

<li>在实体类上加相关的注解
<table>


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="left">@Entity 注解</td>
<td class="left">用来标识类是一个与数据库关联的实体类。这个注解作用在类上面。</td>
</tr>

<tr>
<td class="left">@Id 注解</td>
<td class="left">让hibernate把当前属性解析为一个主键</td>
</tr>

<tr>
<td class="left">@Basic 注解</td>
<td class="left">用来表示，让 hibernate 把当前属性解析为一个表的普通字段。要注意，如果有些java基本类型，没有任何注解的话，默认是带有 @Basic 注解的。</td>
</tr>

<tr>
<td class="left">@Table 注解</td>
<td class="left">用来自定义生成表的详细信息的。作用在类上面。必须要联合 @Entity 注解一起使用。</td>
</tr>

<tr>
<td class="left">@Column 注解</td>
<td class="left">用来自定义生成字段的详细信息的。可选的，配合 @Id 或 @Basic 一起使用。</td>
</tr>

<tr>
<td class="left">@GeneratedValue 注解</td>
<td class="left">用来自定义主键的自动生成策略，如果不带任何参数，那么默认的策略是 AUTO，即让 Hibernate 自动选择生成主键值的方法。这个注解要跟 @Id 一起配合使用。一般情况下，这个也是不可或缺的。</td>
</tr>

<tr>
<td class="left">@Transient 注解</td>
<td class="left">用来将指定属性排除掉，不进行持久化</td>
</tr>
</tbody>
</table>
</li>
</ol>
</li>

<li>在 hibernate.cfg.xml 中添加映射，开始连接
<ol class="org-ol">
<li>创建 sessionFactory
<pre class="example">
他就是一个大内总管，负责初始化 hibernate，并携带所有的配置信息，而且要负责我们跟数据库打交道的一切杂务。
</pre>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#21152;&#36733;&#37197;&#32622;&#25991;&#20214;</span>
  <span style="color: #228b22;">Configuration</span> <span style="color: #a0522d;">config</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">Configuration</span><span style="color: #707183;">()</span>.configure<span style="color: #707183;">(</span> <span style="color: #8b2252;">"/hibernate/helloworld/hello.cfg.xml"</span><span style="color: #707183;">)</span>;
<span style="color: #b22222;">// </span><span style="color: #b22222;">&#21021;&#22987;&#21270;&#25152;&#26377;&#38656;&#35201;&#30340;&#26381;&#21153;</span>
  <span style="color: #228b22;">ServiceRegistry</span> <span style="color: #a0522d;">serviceRegistry</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">StandardServiceRegistryBuilder</span><span style="color: #707183;">()</span>.applySettings<span style="color: #707183;">(</span>config.getProperties<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>.build<span style="color: #707183;">()</span>;

      <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22312;&#23436;&#25104; sessionFactory &#30340;&#21019;&#24314;&#20043;&#21069;&#65292;&#21487;&#20197;&#36890;&#36807; config.addXXX &#30340;&#26041;&#24335;&#65292;&#21160;&#24577;&#28155;&#21152;&#23454;&#20307;&#31867;&#30340;&#26144;&#23556;&#20449;&#24687;</span>
  config.addAnnotatedClass<span style="color: #707183;">(</span>Author.<span style="color: #a020f0;">class</span><span style="color: #707183;">)</span>;
  config.addResource<span style="color: #707183;">(</span><span style="color: #8b2252;">"hibernate/helloworld/Book.hbm.xml"</span><span style="color: #707183;">)</span>;

<span style="color: #b22222;">// </span><span style="color: #b22222;">&#21019;&#24314; sessionFactory &#23545;&#35937;</span>
  <span style="color: #228b22;">SessionFactory</span> <span style="color: #a0522d;">sessionFactory</span> = config.buildSessionFactory<span style="color: #707183;">(</span>serviceRegistry<span style="color: #707183;">)</span>;
</pre>
</div>
</li>

<li>创建 session
</li>
<li>创建 Transaction
</li>
<li>通过 Query 等进行查询；通过 save/delete 等进行增删。
</li>
<li>提交事务，关闭 session，关闭 SessionFactory。
</li>
</ol>
</li>
</ol>
</div>
</section>



<section id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Load/Get</h2>
<div class="outline-text-2" id="text-3">
<p>
get 跟 load 的区别如下：
</p>
<ol class="org-ol">
<li>如果查询的数据不存在的话，get 会返回 null；load 会抛出异常。
</li>
<li>get 是立即从数据库中检索数据； load 是懒加载，即只有当要使用对象的时刻，才进行加载，懒加载是通过代理实现的。
</li>
</ol>
</div>
</section>


<section id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Session 操作</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> session.flush()</h3>
<div class="outline-text-3" id="text-4-1">
<p>
是让 hibernate 立即执行 sql 语句，但是并不提交，同时更新session缓存。{即同步 session 里的缓存到数据库（插入，更新，删除等）。}
</p>

<pre class="example">
只有在调用了 session.flush() 之后，session缓存里的数据，才会被发送到数据库，进行真正的数据库持久化操作。
</pre>

<p>
以下几种清空可以调用 flush:
</p>
<ol class="org-ol">
<li>我们可以在代码中显式调用。在调用的时候，会向数据库中发送操作指令。
<pre class="example">
session.flush();
</pre>
</li>

<li>我们在调用 commit 的时候，也会隐式调用 flush 方法。
<pre class="example">
session.commit();
</pre>
<p>
commit() 方法，其实就是简单调用了 session.flush() 和 conn.commit()。所以数据会被同步到数据库，而且，事务会提交。
</p>
</li>

<li>在执行查询的时候，会隐式调用 flush 方法.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #008b8b;">@Test</span>
<span style="color: #a020f0;">public</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">testFlush</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26356;&#26032;&#32531;&#23384;</span>
     <span style="color: #228b22;">Author</span> <span style="color: #a0522d;">author</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">Author</span><span style="color: #7388d6;">()</span>;
     author.setName<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"struts...."</span><span style="color: #7388d6;">)</span>;
     author.setBirth<span style="color: #7388d6;">(</span><span style="color: #a020f0;">new</span> <span style="color: #228b22;">Date</span><span style="color: #909183;">()</span><span style="color: #7388d6;">)</span>;

     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25968;&#25454;&#21482;&#26159;&#23384;&#22312;&#20110; session &#30340;&#32531;&#23384;&#20013;</span>
     session.save<span style="color: #7388d6;">(</span>author<span style="color: #7388d6;">)</span>;

   <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20174;&#25968;&#25454;&#24211;&#20013;&#36827;&#34892; query &#26597;&#35810;&#30340;&#26102;&#20505;&#65292;&#20250;&#35302;&#21457; flush &#35821;&#21477;&#12290;       </span>
     <span style="color: #228b22;">Query</span> <span style="color: #a0522d;">query</span> = session.createQuery<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"from Author"</span><span style="color: #7388d6;">)</span>;
     System.out.println<span style="color: #7388d6;">(</span>query.list<span style="color: #909183;">()</span>.size<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span>;

     System.out.println<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"ssss"</span><span style="color: #7388d6;">)</span>;
 <span style="color: #707183;">}</span>
</pre>
</div>
</li>
</ol>
</div>
</div>


<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> session.refresh()</h3>
<div class="outline-text-3" id="text-4-2">
<p>
在查询的时候，从数据库中更新数据。
</p>

<p>
所以 refresh 会触发一次查询操作，保证取到的是跟数据库中一致的数据。
</p>
</div>
</div>


<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> session.clear()</h3>
<div class="outline-text-3" id="text-4-3">
<p>
清空整个的 session 缓存内容。
</p>
</div>
</div>
</section>


<section id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 关联映射(Assoc)</h2>
<div class="outline-text-2" id="text-5">
<p>
在数据库中，存在多张表，表根表之间通过外键的形式进行的关联。
</p>

<p>
在 Java 中，存在的是多个类，类之间是通过互相引用的形式进行沟通。
</p>

<p>
ORM 主要是用面向对象的思维去操作数据库。
</p>

<p>
所以，在操作 Java 中的对象，或者修改对象之间的关系的时候，ORM 框架能够帮我们完成相应的数据库的修改。
</p>

<p>
我们需要在 Java 中设置类之间的相互关系，ORM 框架（hibernate）才能够正确的进行这种转换。
</p>

<p>
我们可以通过 xml 或者 annotation 的形式，声明类之间的关系，hibernate 才能正确将这种关系映射到数据库操作上。
</p>

<p>
目前为止，先模仿，后理解。练习越多，越明白。只看不练，空把式。
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 一对一（主键关联）</h3>
<div class="outline-text-3" id="text-5-1">
<p>
[例] IdCard 和 Person 是一对一的关联关系
</p>

<p>
<b>XML 的配置方式：</b>
</p>
<div class="org-src-container">

<pre class="src src-xml"><span style="color: #b22222;">&lt;!--</span><span style="color: #b22222;"> &#22312;&#20854;&#20013;&#19968;&#31471;&#65292;&#37197;&#32622; One-To-One &#33410;&#28857; </span><span style="color: #b22222;">--&gt;</span>
&lt;<span style="color: #0000ff;">one-to-one</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">person</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">class</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate.Person</span><span style="color: #8b2252;">"</span> /&gt;


<span style="color: #b22222;">&lt;!--</span><span style="color: #b22222;"> &#22312;&#21478;&#19968;&#31471;&#65292;&#37197;&#32622; One-To-One &#33410;&#28857;&#65292;&#27880;&#24847;&#65292;&#35201;&#21152;&#19978;Constrained="true" </span><span style="color: #b22222;">--&gt;</span>
<span style="color: #b22222;">&lt;!--</span><span style="color: #b22222;"> &#32780;&#19988;&#35201;&#37197;&#32622;&#20027;&#38190;&#30340;&#29983;&#25104;&#26041;&#24335;&#20026; foreign. </span><span style="color: #b22222;">--&gt;</span>
&lt;<span style="color: #0000ff;">id</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">id</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">type</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">int</span><span style="color: #8b2252;">"</span>&gt;
  &lt;<span style="color: #0000ff;">column</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">ID</span><span style="color: #8b2252;">"</span> /&gt;
  &lt;<span style="color: #0000ff;">generator</span> <span style="color: #a0522d;">class</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">foreign</span><span style="color: #8b2252;">"</span>&gt;
    &lt;<span style="color: #0000ff;">param</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">property</span><span style="color: #8b2252;">"</span>&gt;person&lt;/<span style="color: #0000ff;">param</span>&gt;
  &lt;/<span style="color: #0000ff;">generator</span>&gt;
&lt;/<span style="color: #0000ff;">id</span>&gt;
&lt;<span style="color: #0000ff;">one-to-one</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">IdCard</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">class</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">hibernate.IdCard</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">constrained</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">true</span><span style="color: #8b2252;">"</span> /&gt;
</pre>
</div>

<p>
<b>Anno 的配置方式：</b>
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #008b8b;">@Entity</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Person</span> <span style="color: #707183;">{</span>
    <span style="color: #008b8b;">@OneToOne</span>
    <span style="color: #008b8b;">@JoinColumn</span>
    <span style="color: #a020f0;">private</span> <span style="color: #228b22;">IdCard</span> <span style="color: #a0522d;">idcard</span>;
<span style="color: #707183;">}</span>


<span style="color: #008b8b;">@Entity</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">IdCard</span> <span style="color: #707183;">{</span>
    <span style="color: #008b8b;">@OneToOne</span>
    <span style="color: #008b8b;">@JoinColumn</span>
    <span style="color: #a020f0;">private</span> <span style="color: #228b22;">Person</span> <span style="color: #a0522d;">person</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 一对一（外键关联）</h3>
<div class="outline-text-3" id="text-5-2">
<p>
<b>XML 的形式：</b>
</p>
<div class="org-src-container">

<pre class="src src-xml"><span style="color: #b22222;">&lt;!--</span><span style="color: #b22222;"> &#22312;&#20854;&#20013;&#19968;&#31471; ManyToOne &#21644; unique &#37197;&#21512;&#65292;&#20135;&#29983;&#19968;&#23545;&#19968;&#30340;&#32467;&#26524;&#65292;&#29983;&#25104;&#30456;&#24212;&#22806;&#38190; </span><span style="color: #b22222;">--&gt;</span>
&lt;<span style="color: #0000ff;">many-to-one</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">person</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">class</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">Person</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">unique</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">true</span><span style="color: #8b2252;">"</span> /&gt;

<span style="color: #b22222;">&lt;!--</span><span style="color: #b22222;"> &#22312;&#21478;&#19968;&#31471; </span><span style="color: #b22222;">--&gt;</span>
&lt;<span style="color: #0000ff;">one-to-one</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">idcard</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">class</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">IdCard</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">property-ref</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">person</span><span style="color: #8b2252;">"</span> /&gt;
</pre>
</div>

<p>
<b>Anno 的形式：</b>
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #008b8b;">@Entity</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Person</span> <span style="color: #707183;">{</span>
    <span style="color: #008b8b;">@OneToOne</span>
    <span style="color: #008b8b;">@JoinColumn</span><span style="color: #7388d6;">(</span>mappedBy=<span style="color: #8b2252;">"person"</span><span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">private</span> <span style="color: #228b22;">Card</span> <span style="color: #a0522d;">card</span>;
<span style="color: #707183;">}</span>


<span style="color: #008b8b;">@Entity</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">IdCard</span> <span style="color: #707183;">{</span>
    <span style="color: #008b8b;">@ManyToOne</span>
    <span style="color: #008b8b;">@JoinColumn</span><span style="color: #7388d6;">(</span>name=<span style="color: #8b2252;">"cardid"</span><span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">private</span> <span style="color: #228b22;">Person</span> <span style="color: #a0522d;">person</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> 多对一（单向）</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#20363;&#22914;&#65292;&#19968;&#26412;&#20070;&#65292;&#32943;&#23450;&#26377;&#19968;&#20010;&#20316;&#32773;&#65292;&#32780; author &#23646;&#24615;&#19981;&#26159;&#19968;&#20010;&#31616;&#21333;&#31867;&#22411;&#65292;&#32780;&#26159;&#19968;&#20010;&#23545;&#35937;&#30340;&#24341;&#29992;&#12290;</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">&#20070;&#36319;&#20316;&#32773;&#26159;&#19968;&#20010;&#22810;&#23545;&#19968;&#30340;&#20851;&#31995;&#65292;&#20063;&#23601;&#26159;&#19968;&#20010;&#20316;&#32773;&#26377;&#22810;&#26412;&#20070;</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">&#22312;&#36825;&#31181;&#24773;&#20917;&#20043;&#19979;&#65292;&#25105;&#20204;&#38656;&#35201;&#29992; @ManyToOne &#27880;&#35299; &#25110;&#32773;&#29992; &lt;many-to-one /&gt; &#26631;&#31614;&#21435;&#23450;&#20041;&#36825;&#20010;&#23646;&#24615;&#36319;&#34920;&#23383;&#27573;&#20043;&#38388;&#30340;&#26144;&#23556;&#12290;</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">many-to-one&#65292;&#36825;&#20010;&#26631;&#31614;&#30340;&#20316;&#29992;&#26159;&#20026;&#25152;&#22312;&#30340;&#21015;&#65292;&#28155;&#21152;&#19968;&#20010;&#22806;&#38190;&#32422;&#26463;&#12290;&#22914;&#26524;&#19981;&#26174;&#24335;&#25351;&#23450; column &#21517;&#23383;&#30340;&#35805;&#65292;&#37027;&#20040;&#40664;&#35748;&#29983;&#25104;&#30340;&#21517;&#23383;&#26159; &#23646;&#24615;&#21517;_&#32034;&#24341;&#30340;&#20027;&#38190;&#21517;</span>
<span style="color: #008b8b;">@Entity</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Book</span> <span style="color: #707183;">{</span>
  <span style="color: #008b8b;">@ManyToOne</span>
  <span style="color: #a020f0;">private</span> <span style="color: #228b22;">Author</span> <span style="color: #a0522d;">author</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
many-to-one 可以设置 lazy=(false|proxy|no-proxy), fetch=(select|join)。
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 一对多（单向）</h3>
<div class="outline-text-3" id="text-5-4">
<p>
比如，Father 和 Son 是一对多关联
</p>

<p>
<b>XML 方式：</b>
</p>
<div class="org-src-container">

<pre class="src src-xml">&lt;<span style="color: #0000ff;">set</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">sons</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">cascade</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">save-update</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">lazy</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">extra</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">fetch</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">select</span><span style="color: #8b2252;">"</span>&gt;
  &lt;<span style="color: #0000ff;">key</span> <span style="color: #a0522d;">column</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">father_id</span><span style="color: #8b2252;">"</span>&gt;&lt;/<span style="color: #0000ff;">key</span>&gt;
  &lt;<span style="color: #0000ff;">one-to-many</span> <span style="color: #a0522d;">class</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">Son</span><span style="color: #8b2252;">"</span> /&gt;
&lt;/<span style="color: #0000ff;">set</span>&gt;
</pre>
</div>

<p>
lazy 有下面几个选项： false/true/extra。默认是 true。
</p>
<ul class="org-ul">
<li>如果设置为 false，那么立即加载，加载的方式是多条 select 语句。
</li>
<li>如果设置为 true，会启用懒加载。只有在调用 books 的任何方法时，才会去初始化列表，从而触发从数据库中查询图书列表的请求。
</li>
<li>如果设置为 extra，也会启用懒加载，但是是更加智能化的懒加载。这时候，如果去调用 books.size() 或 books.contains() 等方法时，并不会真正的初始化图书列表。这样能尽可能节省资源。
</li>
</ul>

<p>
fetch 有以下几个选项：
</p>
<ul class="org-ul">
<li>如果设置了 select，那么，查询的是多条 select 语句。这是默认值。
</li>
<li>如果设置了 join，那么 lazy 的设置会无效，会变成立即加载。加载的语句为 left join 方式
</li>
<li>如果设置了 subselect，那么多个查询会尽量合并成子查询形式
</li>
</ul>


<p>
<b>Anno 方式：</b>
</p>

<p>
实现一对多的单向关联，只需在代表一的实体中使用 @OneToMany 映射标注，代表多的实体不需要使用任何映射标注。
</p>

<p>
如果只注明 @OneToMany，会通过建立第三方表来保存关系。如果额外添加 @JoinColumn 标注，则会在多的一方增加一个外键列来保存关系。
</p>

<p>
通过 cascade 可以设置级联属性；通过 fetch 可以设置是否采用懒加载；通过 @Fetch 注解可以指定查询语句的形式。
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#21333;&#21521;&#20851;&#31995;&#65292;&#21482;&#38656;&#35201;&#22312;&#19968;&#26041;&#21152;&#27880;&#35299;&#21363;&#21487;</span>
<span style="color: #008b8b;">@Entity</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Father</span> <span style="color: #707183;">{</span>
    <span style="color: #008b8b;">@OneToMany</span><span style="color: #7388d6;">(</span>cascade=<span style="color: #008b8b;">CascadeType</span>.ALL, fetch=<span style="color: #008b8b;">FetchType</span>.LAZY<span style="color: #7388d6;">)</span>
    <span style="color: #008b8b;">@JoinColumn</span><span style="color: #7388d6;">(</span><span style="color: #8b2252;">"father_id"</span><span style="color: #7388d6;">)</span>   <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36825;&#19968;&#21477;&#23548;&#33268;&#19981;&#20250;&#20986;&#29616;&#20013;&#38388;&#34920;&#65292;&#24182;&#22312; son &#34920;&#20013;&#28155;&#21152;&#21517;&#20026; father_id &#30340;&#22806;&#38190;&#21015;&#12290;</span>
    <span style="color: #a020f0;">private</span> <span style="color: #228b22;">Set</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Son</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">sons</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">HashSet</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Son</span><span style="color: #7388d6;">&gt;()</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> 一对多（双向）</h3>
<div class="outline-text-3" id="text-5-5">
<p>
在JPA规范中，一对多的双向关系只能由多端(Son)来维护。
</p>

<p>
在代表多的一端(son)，注解 @ManyToOne，并由 @JoinColumn 设置 son 中的关联字段（外键）。<br >
在代表一的一端(father)，注解 @OneToMany，并由参数的 mappedBy="father" 属性标注为关系被维护端。
</p>

<p>
<b>XML 方式：</b>
</p>
<div class="org-src-container">

<pre class="src src-xml">&lt;<span style="color: #0000ff;">set</span> <span style="color: #a0522d;">name</span>=sons" <span style="color: #a0522d;">inverse</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">true</span><span style="color: #8b2252;">"</span>&gt;
  &lt;<span style="color: #0000ff;">key</span> <span style="color: #a0522d;">column</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">father_id</span><span style="color: #8b2252;">"</span>&gt;&lt;/<span style="color: #0000ff;">key</span>&gt;
  &lt;<span style="color: #0000ff;">one-to-many</span> <span style="color: #a0522d;">class</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">Son</span><span style="color: #8b2252;">"</span> /&gt;
&lt;/<span style="color: #0000ff;">set</span>&gt;

&lt;<span style="color: #0000ff;">many-to-one</span> <span style="color: #a0522d;">name</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">father</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">column</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">father_id</span><span style="color: #8b2252;">"</span> <span style="color: #a0522d;">class</span>=<span style="color: #8b2252;">"</span><span style="color: #8b2252;">Father</span><span style="color: #8b2252;">"</span> /&gt;
</pre>
</div>

<p>
<b>Anno 方式：</b>
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#20027;&#31471;&#65292;&#22810;</span>
<span style="color: #008b8b;">@Entity</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Son</span> <span style="color: #707183;">{</span>
    <span style="color: #008b8b;">@ManyToOne</span><span style="color: #7388d6;">(</span>optional=<span style="color: #008b8b;">false</span><span style="color: #7388d6;">)</span>       <span style="color: #b22222;">// </span><span style="color: #b22222;">optional&#30340;&#24847;&#24605;&#26159;&#65292;father &#19981;&#33021;&#20026;&#31354;</span>
    <span style="color: #008b8b;">@JoinColumn</span><span style="color: #7388d6;">(</span>name=<span style="color: #8b2252;">"father_id"</span><span style="color: #7388d6;">)</span>    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35774;&#32622;&#22312;son&#34920;&#20013;&#30340;&#20851;&#32852;&#23383;&#27573;(&#22806;&#38190;)</span>
    <span style="color: #a020f0;">private</span> <span style="color: #228b22;">Father</span> <span style="color: #a0522d;">father</span>;
<span style="color: #707183;">}</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">&#20174;&#31471;&#65292;&#19968;</span>
<span style="color: #008b8b;">@Entity</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Father</span> <span style="color: #707183;">{</span>
    <span style="color: #008b8b;">@OneToMany</span><span style="color: #7388d6;">(</span>mappedBy=<span style="color: #8b2252;">"father"</span>, fetch=<span style="color: #008b8b;">FetchType</span>.LAZY<span style="color: #7388d6;">)</span>
    <span style="color: #a020f0;">private</span> <span style="color: #228b22;">Set</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Son</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">sons</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">HashSet</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Son</span><span style="color: #7388d6;">&gt;()</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
可以看到，生成的只有两张表， SON/FATHER，SON 持有关联到 FATHER 的外键。
</p>

<p>
首先，必须要保证 上面的 column 跟下面的 column 要一致，否则，会在创建表的时候，生成重复的字段，产生不必要的问题。
</p>

<p>
其次，要在 set 上面配置 inverse="true"，否则，会在生成语句的时候，产生很多很多的冗余。在一对多双向关系中，一般情况下，要在多的一边设置 inverse。
</p>

<p>
还要注意，在保存的时候，要先保存 1 的一方，否则，会产生很多不必要的 update 语句，从而影响效率。
</p>
</div>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> 多对多（双向）</h3>
<div class="outline-text-3" id="text-5-6">
<p>
JPA中使用 @ManyToMany 来注解多对多的关系。
</p>

<p>
多对多的关系，需要使用一张中间表来维护关系。
</p>

<p>
在 hibernate 中，可以指定其中一方去维护关系，另一边只需要添加 mappedBy 即可。
</p>

<p>
生产环境中，多对多关系一般不设置级联操作。
</p>

<p>
如果已经绑定了多对多的关系，不能直接删除从断，需要主端解除绑定再删除。但可以直接删除主端。
</p>

<p>
[例] 游戏和玩家是多对多的关系：一款游戏有多个人在玩，一个人玩多个游戏。
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #008b8b;">@Entity</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Player</span> <span style="color: #707183;">{</span>
  <span style="color: #008b8b;">@ManyToMany</span>
  <span style="color: #008b8b;">@JoinTable</span><span style="color: #7388d6;">(</span>name=<span style="color: #8b2252;">"QQGame"</span>, joinColumns=<span style="color: #008b8b;">@JoinColumn</span><span style="color: #909183;">(</span>name=<span style="color: #8b2252;">"player_id"</span><span style="color: #909183;">)</span>, inverseJoinColumns=<span style="color: #008b8b;">@JoinColumn</span><span style="color: #909183;">(</span>name=<span style="color: #8b2252;">"game_id"</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20851;&#31995;&#32500;&#25252;&#31471;&#65292;&#36127;&#36131;&#22810;&#23545;&#22810;&#20851;&#31995;&#30340;&#32465;&#23450;&#21644;&#35299;&#38500;</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21487;&#20197;&#19981;&#25351;&#23450; @JoinTable&#65292;&#37027;&#20040;&#20013;&#38388;&#34920;&#12289;&#22806;&#38190;&#21517;&#31561;&#23601;&#20250;&#37319;&#29992;&#40664;&#35748;&#20540;</span>
  <span style="color: #a020f0;">private</span> <span style="color: #228b22;">Set</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Game</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">games</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">HashSet</span><span style="color: #7388d6;">&lt;&gt;()</span>;
<span style="color: #707183;">}</span>


<span style="color: #008b8b;">@Entity</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Game</span> <span style="color: #707183;">{</span>
  <span style="color: #008b8b;">@ManyToMany</span><span style="color: #7388d6;">(</span>mappedBy=<span style="color: #8b2252;">"games"</span><span style="color: #7388d6;">)</span>
  <span style="color: #a020f0;">private</span> <span style="color: #228b22;">Set</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Player</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">players</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">HashSet</span><span style="color: #7388d6;">&lt;&gt;()</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>
</section>

<section id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 继承(Inheritance)</h2>
<div class="outline-text-2" id="text-6">
<p>
开发的时候用的不是特别多。
</p>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> subclass</h3>
<div class="outline-text-3" id="text-6-1">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #008b8b;">@Inheritance</span><span style="color: #707183;">(</span>strategy=<span style="color: #008b8b;">InheritanceType</span>.SINGLE_TABLE<span style="color: #707183;">)</span>
<span style="color: #008b8b;">@DiscriminatorColumn</span><span style="color: #707183;">(</span>name=<span style="color: #8b2252;">"xxx"</span><span style="color: #707183;">)</span>
<span style="color: #008b8b;">@DiscriminatorValue</span><span style="color: #707183;">(</span>value=<span style="color: #8b2252;">"e"</span><span style="color: #707183;">)</span>
<span style="color: #a020f0;">class</span> Dog <span style="color: #228b22;">extents</span> <span style="color: #228b22;">Animal</span> <span style="color: #707183;">{</span> ... <span style="color: #707183;">}</span>
</pre>
</div>

<p>
特点：
</p>
<ul class="org-ul">
<li>只有一张表，查询快速
</li>
<li>使用了区别列
</li>
<li>子类独有列不能添非空约束
</li>
<li>继承层次深则冗余字段很多
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> joined-class</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #008b8b;">@Inheritance</span><span style="color: #707183;">(</span>strategy=<span style="color: #008b8b;">InheritanceType</span>.JOINED<span style="color: #707183;">)</span>
<span style="color: #008b8b;">@Entity</span>
<span style="color: #008b8b;">@PrimaryKeyJoinColumn</span><span style="color: #707183;">(</span>name=<span style="color: #8b2252;">"xxx"</span><span style="color: #707183;">)</span>
<span style="color: #a020f0;">class</span> Dog <span style="color: #228b22;">extents</span> <span style="color: #228b22;">Animal</span> <span style="color: #707183;">{</span> ... <span style="color: #707183;">}</span>
</pre>
</div>

<p>
特点：
</p>
<ul class="org-ul">
<li>查询父类记录，做一个左连接查询
</li>
<li>查询子记录，做一个内联接查询
</li>
<li>查询效率略低
</li>
<li>没有冗余的字段
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> union-subclass</h3>
<div class="outline-text-3" id="text-6-3">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #008b8b;">@Inheritance</span><span style="color: #707183;">(</span>strategy=<span style="color: #008b8b;">InheritanceType</span>.TABLE_PER_CLASS<span style="color: #707183;">)</span>
</pre>
</div>

<p>
特点：
</p>
<ul class="org-ul">
<li>每个实现类都有一个独立的表
</li>
<li>查子类不错，查父类需要union
</li>
<li>但存在冗余字段
</li>
<li>若更新父表的字段，效率较低
</li>
</ul>
</div>
</div>
</section>
<section id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 级联（Cascade）</h2>
<div class="outline-text-2" id="text-7">
<p>
在利用 hibernate 对实体类对象进行持久化(如 session.save)的时候，需要保证里面引用的对象已经处于持久化状态。
</p>

<p>
否则，会出现以下异常
</p>
<pre class="example">
org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance before flushing: hibernate.assoc.many2one.Author
</pre>

<p>
解决方案有以下两种：
</p>
<ol class="org-ol">
<li>在保存对象前，对所有引用到的对象先执行持久化操作。
</li>
<li>在实体类中，为这些引用到的对象，设置合适的级联属性。这样的话，hibernate 会在保存对象的时候，自动将引用到的还没有持久化的对象进行持久化。
</li>
</ol>

<p>
级联可以通过注解的形式进行配置，也可以通过 XML 的形式进行配置。
</p>
<pre class="example">
@ManyToOne(cascade=CascadeType.PERSIST)
&lt;many-to-one cascade="save-update" /&gt;
</pre>

<p>
大抵有如下几种：
</p>
<pre class="example">
none：在保存，删除或修改当前对象时，不对其附属对象（关联对象）进行级联操作，它是默认值。 
save-update：在保存，更新当前对象时，级联保存，更新附属对象（临时对象、游离对象）。 
delete：在删除当前对象时，级联删除附属对象。 
all：所有情况下均进行级联操作，即包含 save-update 和 delete 操作
</pre>


<p>
在我们的开发环境中，设置好 cascade 会让我们的代码更整洁，测试更方便。但是，在工业环境中，不建议使用任何 cascade 设置。
</p>
</div>
</section>

<section id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 检索策略</h2>
<div class="outline-text-2" id="text-8">
<p>
把握的原则是：
</p>
<ol class="org-ol">
<li>不浪费内存
</li>
<li>更高的效率。(如尽量少的sql语句)
</li>
</ol>

<p>
类级别的检索策略：
</p>
<ul class="org-ul">
<li>分为立即检索 和 延迟检索
</li>
<li>类级别检索策略可以通过&lt;class&gt;的 lazy 属性进行控制
</li>
<li>class 的 lazy 仅对 load() 方法有效
</li>
<li>延迟检索返回的是代理对象。所以注意不要发生懒加载异常。
</li>
<li>class 的 batch-size，全局批量模式
</li>
</ul>

<p>
&lt;set&gt;元素的检索策略：
</p>
<ul class="org-ul">
<li>lazy，决定集合被初始化的时机，true/false/extra
</li>
<li>Hibernate.initialize() 调用代码显式初始化
</li>
<li>fetch 的选项有："select"，"subselect"，"join"，它们决定查询的形式和时机
</li>
<li>若把 fetch 设置为 subselect，会通过子查询的方式来初始化所有 set 集合。
子查询作为 where 的 in 条件出现。此时 lazy 有效，batch-size 失效。
</li>
<li>若把 fetch 设置为 join，迫切使用左连接，lazy 会失效。
</li>
<li>hql 查询会忽略 fetch=join 的取值
</li>
<li>batch-size，设定批量查询数量，用于减少 select 次数、提高检索性能
</li>
<li>order-by 在查询时对集合中的元素进行排序，使用的是表的字段名。会在 sql 语句中添加 order by 段。
</li>
</ul>

<p>
&lt;many-to-one&gt;的检索策略:
</p>
<ul class="org-ul">
<li>lazy 取值 proxy/no-proxy/false
</li>
</ul>

<p>
&lt;property /&gt; 的检索策略:
</p>
<ul class="org-ul">
<li>lazy 取值 true/false
</li>
</ul>
</div>
</section>

<section id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 检索方式</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> HQL</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>基本用法
</li>
<li>分页查询
</li>
<li>投影查询
</li>
<li>NamedQuery
</li>
<li>内外连接
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> QBC</h3>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> SQLQuery</h3>
<div class="outline-text-3" id="text-9-3">
<ul class="org-ul">
<li>基本语法
</li>
<li>增加条件（addScalar）
</li>
<li>返回结果（addEntity）
</li>
</ul>
</div>
</div>
</section>
<section id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 二级缓存</h2>
<div class="outline-text-2" id="text-10">
<ol class="org-ol">
<li>加入 hibernate-ehcache.jar 及关联包
</li>
<li>创建/复制 ehcachexml 到类路径
</li>
<li>配置 hibernate.cfg.xml
<pre class="example">
&lt;property name="cache.user_second_level_cache"&gt;true&lt;/property&gt;
&lt;property name="cache.cache.region.factory_class"&gt;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/property&gt;
</pre>
</li>
<li>配置要被缓存的类
<ul class="org-ul">
<li>在 hibernate.cfg.xml 中配置
<pre class="example">
&lt;class-cache usage="read-only" class="ccc.hibernate.cache.Employee"/&gt;
</pre>
</li>
<li>在 .hbm.xml 中添加
<pre class="example">
&lt;cache usage="read-only"/&gt;
</pre>
</li>
<li>在类或集合上添加
<pre class="example">
@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)
</pre>
</li>
</ul>
</li>
</ol>
</div>
</section>


<section id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 乐观锁、悲观锁</h2>
</section>
</div>
<div id="postamble" class="status">
<p class="author">Author: imfine</p>
<p class="date">Created: 2017-03-15 周三 16:38</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation">Go ahead, never stop.</p>
</div>
</body>
</html>
