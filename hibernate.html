<!DOCTYPE html>
<html>
<head>
<title>Hibernate ORM</title>
<!-- 2016-11-10 周四 06:39 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="imfine">
<link rel="stylesheet" href="ss.css">
</head>
<body>
<div id="content">
<h1 class="title">Hibernate ORM</h1>
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">基本知识</a></li>
<li><a href="#sec-2">起步</a></li>
<li><a href="#sec-3">Load/Get</a></li>
<li><a href="#sec-4">session.flush()</a></li>
<li><a href="#sec-5">session.refresh()</a></li>
<li><a href="#sec-6">session.clear()</a></li>
<li><a href="#sec-7">ManyToOne</a></li>
<li><a href="#sec-8">OneToMany</a>
<ul>
<li><a href="#sec-8-1">xml 中的配置</a></li>
<li><a href="#sec-8-2">注解的形式</a></li>
</ul>
</li>
<li><a href="#sec-9">One.Many.双向</a>
<ul>
<li><a href="#sec-9-1">在 xml 中配置</a></li>
<li><a href="#sec-9-2">通过注解的方式进行配置</a></li>
</ul>
</li>
<li><a href="#sec-10">Cascade</a></li>
<li><a href="#sec-11">Fetch</a></li>
<li><a href="#sec-12">Roll</a></li>
<li><a href="#sec-13">改写 hello，增加 hibernate 支持</a></li>
<li><a href="#sec-14">Java 提高</a>
<ul>
<li><a href="#sec-14-1">日期与时间</a>
<ul>
<li><a href="#sec-14-1-1">Date 类</a></li>
<li><a href="#sec-14-1-2">Calendar 类</a></li>
<li><a href="#sec-14-1-3">其它</a></li>
</ul>
</li>
<li><a href="#sec-14-2">getter 代码，实现更好的封装</a></li>
</ul>
</li>
</ul>
</div>
</nav>



<section id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">基本知识</h2>
<div class="outline-text-2" id="text-1">
<p>
ORM:
</p>
<pre class="example">
Object-Relationship Mapping
</pre>
<p>
对象，跟数据库，有着某种对应关系
</p>
<table>


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="left">类</td>
<td class="left">表的结构(MetaData)</td>
</tr>

<tr>
<td class="left">实例化的对象</td>
<td class="left">每一条数据</td>
</tr>

<tr>
<td class="left">对象的每个属性</td>
<td class="left">数据的每个字段</td>
</tr>
</tbody>
</table>

<p>
面向对象的封装，让我们在编程的过程中用更自然的思维处理问题，
所以在操作数据库的时候，需要把数据库里的数据跟我们创建的对象关联起来。
我们可以手动写代码实现这个过程。
也可以通过一些 ORM 框架去实现。Hibernate 就是其中一种非常优秀的框架。
</p>
</div>
</section>

<section id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">起步</h2>
<div class="outline-text-2" id="text-2">
<p>
使用 Hibernate 的步骤:
</p>

<ol class="org-ol">
<li>建立 Web 工程
</li>
<li>将需要用到的 jar 包，拷贝到 lib 包的下面。一定不要放错位置。也不要缺少关键包。也尽量不要有包的冲突。
</li>
<li>创建 hibernate 的配置文件 hibernate.cfg.xml，指定数据库信息、打印sql语句策略等
<div class="org-src-container">

<pre class="src src-xml">&lt;?<span style="color: #0000FF;">xml</span> <span style="color: #BA36A5;">version</span>=<span style="color: #008000;">"</span><span style="color: #008000;">1.0</span><span style="color: #008000;">"</span> <span style="color: #BA36A5;">encoding</span>=<span style="color: #008000;">"</span><span style="color: #008000;">UTF-8</span><span style="color: #008000;">"</span>?&gt;
&lt;!<span style="color: #0000FF;">DOCTYPE</span> hibernate-configuration <span style="color: #0000FF;">PUBLIC</span>
 <span style="color: #036A07;">"</span><span style="color: #036A07;">-//Hibernate/Hibernate Configuration DTD 3.0//EN</span><span style="color: #036A07;">"</span>
 <span style="color: #036A07;">"</span><span style="color: #036A07;">http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd</span><span style="color: #036A07;">"</span>&gt;

&lt;<span style="color: #000088; background-color: #DEDEDE;">hibernate-configuration</span>&gt;
  &lt;<span style="color: #000088; background-color: #DEDEDE;">session-factory</span>&gt;
     <span style="color: #8D8D84;">&lt;!--</span><span style="color: #8D8D84; font-style: italic;"> &#37197;&#32622;&#25968;&#25454;&#24211;&#30340;&#22522;&#26412;&#20449;&#24687; </span><span style="color: #8D8D84;">--&gt;</span>
     &lt;<span style="color: #000088; background-color: #DEDEDE;">property</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">hibernate.connection.driver_class</span><span style="color: #008000;">"</span>&gt;oracle.jdbc.driver.OracleDriver&lt;/<span style="color: #000088; background-color: #DEDEDE;">property</span>&gt;
     &lt;<span style="color: #000088; background-color: #DEDEDE;">property</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">hibernate.connection.url</span><span style="color: #008000;">"</span>&gt;jdbc:oracle:thin:@localhost:1521:orcl&lt;/<span style="color: #000088; background-color: #DEDEDE;">property</span>&gt;
     &lt;<span style="color: #000088; background-color: #DEDEDE;">property</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">hibernate.connection.username</span><span style="color: #008000;">"</span>&gt;vip&lt;/<span style="color: #000088; background-color: #DEDEDE;">property</span>&gt;
     &lt;<span style="color: #000088; background-color: #DEDEDE;">property</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">hibernate.connection.password</span><span style="color: #008000;">"</span>&gt;vip&lt;/<span style="color: #000088; background-color: #DEDEDE;">property</span>&gt;
     &lt;<span style="color: #000088; background-color: #DEDEDE;">property</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">hibernate.dialect</span><span style="color: #008000;">"</span>&gt;org.hibernate.dialect.Oracle10gDialect&lt;/<span style="color: #000088; background-color: #DEDEDE;">property</span>&gt;

     <span style="color: #8D8D84;">&lt;!--</span><span style="color: #8D8D84; font-style: italic;"> &#37197;&#32622; SQL &#35821;&#21477;&#26174;&#31034;&#25110;&#32773; DDL &#29983;&#25104;&#30340;&#31574;&#30053; </span><span style="color: #8D8D84;">--&gt;</span>
     &lt;<span style="color: #000088; background-color: #DEDEDE;">property</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">hibernate.show_sql</span><span style="color: #008000;">"</span>&gt;true&lt;/<span style="color: #000088; background-color: #DEDEDE;">property</span>&gt;
     &lt;<span style="color: #000088; background-color: #DEDEDE;">property</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">hibernate.format_sql</span><span style="color: #008000;">"</span>&gt;true&lt;/<span style="color: #000088; background-color: #DEDEDE;">property</span>&gt;
     &lt;<span style="color: #000088; background-color: #DEDEDE;">property</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">hibernate.hbm2ddl.auto</span><span style="color: #008000;">"</span>&gt;create&lt;/<span style="color: #000088; background-color: #DEDEDE;">property</span>&gt;

     <span style="color: #8D8D84;">&lt;!--</span><span style="color: #8D8D84; font-style: italic;"> &#37197;&#32622;&#19968;&#31995;&#21015;&#30340; Mapping &#25991;&#20214;&#12290;&#20998;&#20026; xml/annotation &#31561;&#26041;&#24335; </span><span style="color: #8D8D84;">--&gt;</span>        
     &lt;<span style="color: #000088; background-color: #DEDEDE;">mapping</span> <span style="color: #BA36A5;">resource</span>=<span style="color: #008000;">"</span><span style="color: #008000;">hibernate/helloworld/Book.hbm.xml</span><span style="color: #008000;">"</span> /&gt;
     &lt;<span style="color: #000088; background-color: #DEDEDE;">mapping</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"</span><span style="color: #008000;">hibernate.helloworld.Book</span><span style="color: #008000;">"</span> /&gt;

  &lt;/<span style="color: #000088; background-color: #DEDEDE;">session-factory</span>&gt;
&lt;/<span style="color: #000088; background-color: #DEDEDE;">hibernate-configuration</span>&gt;
</pre>
</div>
</li>
<li>创建实体类 Book.java
<blockquote>
<p>
注意，要写成 JavaBean 的规范格式。字段用 private 限制，并为每个字段写 getter/setter 方法(property accessor)。
</p>

<p>
还要注意，一个实体类，要跟数据库做映射的话，有一个字段是必须的，就是主键，在 hibernate 中，用 @Id 来表示。
</p>

<p>
还要注意，一个实体类，必须要有一个无参构造器。如果我们在里面写了带参数的构造器，那一定不要忘记，增加一个默认的无参构造器。
</p>
</blockquote>
</li>

<li>创建数据库跟实体类的映射。有两种方式：XML方式、Annotation方式
<ol class="org-ol">
<li>创建相关的xml映射文件 Book.hbm.xml
<div class="org-src-container">

<pre class="src src-xml">&lt;?<span style="color: #0000FF;">xml</span> <span style="color: #BA36A5;">version</span>=<span style="color: #008000;">"</span><span style="color: #008000;">1.0</span><span style="color: #008000;">"</span> <span style="color: #BA36A5;">encoding</span>=<span style="color: #008000;">"</span><span style="color: #008000;">UTF-8</span><span style="color: #008000;">"</span>?&gt;
&lt;!<span style="color: #0000FF;">DOCTYPE</span> hibernate-mapping <span style="color: #0000FF;">PUBLIC</span> 
    <span style="color: #036A07;">"</span><span style="color: #036A07;">-//Hibernate/Hibernate Mapping DTD 3.0//EN</span><span style="color: #036A07;">"</span>
    <span style="color: #036A07;">"</span><span style="color: #036A07;">http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd</span><span style="color: #036A07;">"</span>&gt;

&lt;<span style="color: #000088; background-color: #DEDEDE;">hibernate-mapping</span>&gt;
  <span style="color: #8D8D84;">&lt;!--</span><span style="color: #8D8D84; font-style: italic;"> &#37197;&#32622;&#23454;&#20307;&#31867;&#30340;&#26144;&#23556; </span><span style="color: #8D8D84;">--&gt;</span>
  &lt;<span style="color: #000088; background-color: #DEDEDE;">class</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">hibernate.helloworld.Book</span><span style="color: #008000;">"</span> <span style="color: #BA36A5;">table</span>=<span style="color: #008000;">"</span><span style="color: #008000;">t_book</span><span style="color: #008000;">"</span>&gt;
    &lt;<span style="color: #000088; background-color: #DEDEDE;">id</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">bookno</span><span style="color: #008000;">"</span>&gt;
      &lt;<span style="color: #000088; background-color: #DEDEDE;">generator</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"</span><span style="color: #008000;">native</span><span style="color: #008000;">"</span>&gt;&lt;/<span style="color: #000088; background-color: #DEDEDE;">generator</span>&gt;
    &lt;/<span style="color: #000088; background-color: #DEDEDE;">id</span>&gt;

    &lt;<span style="color: #000088; background-color: #DEDEDE;">property</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">name</span><span style="color: #008000;">"</span>&gt;&lt;/<span style="color: #000088; background-color: #DEDEDE;">property</span>&gt;
    &lt;<span style="color: #000088; background-color: #DEDEDE;">property</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">price</span><span style="color: #008000;">"</span>&gt;&lt;/<span style="color: #000088; background-color: #DEDEDE;">property</span>&gt;
  &lt;/<span style="color: #000088; background-color: #DEDEDE;">class</span>&gt;

  <span style="color: #8D8D84;">&lt;!--</span><span style="color: #8D8D84; font-style: italic;"> &#22312;&#36825;&#37324;&#65292;&#21487;&#20197;&#28155;&#21152;&#20854;&#20182;&#30340;&#23454;&#20307;&#31867;&#26144;&#23556; </span><span style="color: #8D8D84;">--&gt;</span>

&lt;/<span style="color: #000088; background-color: #DEDEDE;">hibernate-mapping</span>&gt;
</pre>
</div>
</li>

<li>在实体类上加相关的注解
<table>


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="left">@Entity 注解</td>
<td class="left">用来标识类是一个与数据库关联的实体类。这个注解作用在类上面。</td>
</tr>

<tr>
<td class="left">@Id 注解</td>
<td class="left">让hibernate把当前属性解析为一个主键</td>
</tr>

<tr>
<td class="left">@Basic 注解</td>
<td class="left">用来表示，让 hibernate 把当前属性解析为一个表的普通字段。要注意，如果有些java基本类型，没有任何注解的话，默认是带有 @Basic 注解的。</td>
</tr>

<tr>
<td class="left">@Table 注解</td>
<td class="left">用来自定义生成表的详细信息的。作用在类上面。必须要联合 @Entity 注解一起使用。</td>
</tr>

<tr>
<td class="left">@Column 注解</td>
<td class="left">用来自定义生成字段的详细信息的。可选的，配合 @Id 或 @Basic 一起使用。</td>
</tr>

<tr>
<td class="left">@GeneratedValue 注解</td>
<td class="left">用来自定义主键的自动生成策略，如果不带任何参数，那么默认的策略是 AUTO，即让 Hibernate 自动选择生成主键值的方法。这个注解要跟 @Id 一起配合使用。一般情况下，这个也是不可或缺的。</td>
</tr>

<tr>
<td class="left">@Transient 注解</td>
<td class="left">用来将指定属性排除掉，不进行持久化</td>
</tr>
</tbody>
</table>
</li>
</ol>
</li>

<li>在 hibernate.cfg.xml 中添加映射，开始连接
<ol class="org-ol">
<li>创建 sessionFactory
<pre class="example">
他就是一个大内总管，负责初始化 hibernate，并携带所有的配置信息，而且要负责我们跟数据库打交道的一切杂务。
</pre>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#21152;&#36733;&#37197;&#32622;&#25991;&#20214;</span>
<span style="color: #6434A3;">Configuration</span> <span style="color: #BA36A5;">config</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">Configuration</span><span style="color: #707183;">()</span>.configure<span style="color: #707183;">(</span> <span style="color: #008000;">"/hibernate/helloworld/hello.cfg.xml"</span><span style="color: #707183;">)</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#21021;&#22987;&#21270;&#25152;&#26377;&#38656;&#35201;&#30340;&#26381;&#21153;</span>
<span style="color: #6434A3;">ServiceRegistry</span> <span style="color: #BA36A5;">serviceRegistry</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">StandardServiceRegistryBuilder</span><span style="color: #707183;">()</span>.applySettings<span style="color: #707183;">(</span>config.getProperties<span style="color: #7388D6;">()</span><span style="color: #707183;">)</span>.build<span style="color: #707183;">()</span>;

<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#22312;&#23436;&#25104; sessionFactory &#30340;&#21019;&#24314;&#20043;&#21069;&#65292;&#21487;&#20197;&#36890;&#36807; config.addXXX &#30340;&#26041;&#24335;&#65292;&#21160;&#24577;&#28155;&#21152;&#23454;&#20307;&#31867;&#30340;&#26144;&#23556;&#20449;&#24687;</span>
config.addAnnotatedClass<span style="color: #707183;">(</span>Author.<span style="color: #0000FF;">class</span><span style="color: #707183;">)</span>;
config.addResource<span style="color: #707183;">(</span><span style="color: #008000;">"hibernate/helloworld/Book.hbm.xml"</span><span style="color: #707183;">)</span>;

<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#21019;&#24314; sessionFactory &#23545;&#35937;</span>
<span style="color: #6434A3;">SessionFactory</span> <span style="color: #BA36A5;">sessionFactory</span> = config.buildSessionFactory<span style="color: #707183;">(</span>serviceRegistry<span style="color: #707183;">)</span>;
</pre>
</div>
</li>

<li>创建 session
</li>
<li>创建 Transaction
</li>
<li>通过 Query 等进行查询；通过 save/delete 等进行增删。
</li>
<li>提交事务，关闭 session，关闭 SessionFactory。
</li>
</ol>
</li>
</ol>
</div>
</section>



<section id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Load/Get</h2>
<div class="outline-text-2" id="text-3">
<p>
get 跟 load 的区别如下：
</p>
<ol class="org-ol">
<li>如果查询的数据不存在的话，get 会返回 null；load 会抛出异常。
</li>
<li>get 是立即从数据库中检索数据； load 是懒加载，即只有当要使用对象的时刻，才进行加载，懒加载是通过代理实现的。
</li>
</ol>
</div>
</section>


<section id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">session.flush()</h2>
<div class="outline-text-2" id="text-4">
<p>
是让 hibernate 立即执行 sql 语句，但是并不提交，同时更新session缓存。{即同步 session 里的缓存到数据库（插入，更新，删除等）。}
</p>

<pre class="example">
只有在调用了 session.flush() 之后，session缓存里的数据，才会被发送到数据库，进行真正的数据库持久化操作。
</pre>

<p>
以下几种清空可以调用 flush:
</p>
<ol class="org-ol">
<li>我们可以在代码中显式调用。在调用的时候，会向数据库中发送操作指令。
<pre class="example">
session.flush();
</pre>
</li>

<li>我们在调用 commit 的时候，也会隐式调用 flush 方法。
<pre class="example">
session.commit();
</pre>
<p>
commit() 方法，其实就是简单调用了 session.flush() 和 conn.commit()。所以数据会被同步到数据库，而且，事务会提交。
</p>
</li>

<li>在执行查询的时候，会隐式调用 flush 方法.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #D0372D;">@Test</span>
<span style="color: #0000FF;">public</span> <span style="color: #6434A3;">void</span> <span style="color: #006699;">testFlush</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
   <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#26356;&#26032;&#32531;&#23384;</span>
   <span style="color: #6434A3;">Author</span> <span style="color: #BA36A5;">author</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">Author</span><span style="color: #7388D6;">()</span>;
   author.setName<span style="color: #7388D6;">(</span><span style="color: #008000;">"struts...."</span><span style="color: #7388D6;">)</span>;
   author.setBirth<span style="color: #7388D6;">(</span><span style="color: #0000FF;">new</span> <span style="color: #6434A3;">Date</span><span style="color: #909183;">()</span><span style="color: #7388D6;">)</span>;

   <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#25968;&#25454;&#21482;&#26159;&#23384;&#22312;&#20110; session &#30340;&#32531;&#23384;&#20013;</span>
   session.save<span style="color: #7388D6;">(</span>author<span style="color: #7388D6;">)</span>;

   <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#20174;&#25968;&#25454;&#24211;&#20013;&#36827;&#34892; query &#26597;&#35810;&#30340;&#26102;&#20505;&#65292;&#20250;&#35302;&#21457; flush &#35821;&#21477;&#12290;     </span>
   <span style="color: #6434A3;">Query</span> <span style="color: #BA36A5;">query</span> = session.createQuery<span style="color: #7388D6;">(</span><span style="color: #008000;">"from Author"</span><span style="color: #7388D6;">)</span>;
   System.out.println<span style="color: #7388D6;">(</span>query.list<span style="color: #909183;">()</span>.size<span style="color: #909183;">()</span><span style="color: #7388D6;">)</span>;

   System.out.println<span style="color: #7388D6;">(</span><span style="color: #008000;">"ssss"</span><span style="color: #7388D6;">)</span>;
 <span style="color: #707183;">}</span>
</pre>
</div>
</li>
</ol>
</div>
</section>


<section id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">session.refresh()</h2>
<div class="outline-text-2" id="text-5">
<p>
在查询的时候，从数据库中更新数据。
</p>

<p>
所以 refresh 会触发一次查询操作，保证取到的是跟数据库中一致的数据。
</p>
</div>
</section>


<section id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">session.clear()</h2>
<div class="outline-text-2" id="text-6">
<p>
清空整个的 session 缓存内容。
</p>


<p>
h* Assoc
因为，在数据库中，存在多张表，表根表之间通过外键的形式进行的关联。
</p>

<p>
但是，在我们的java中，存在的是多个类，类之间是通过互相引用的形式进行沟通。（即一个类中，包含另一个类的引用）。
</p>

<p>
ORM 的主要是，用面向对象的思维去操作数据库。所以，我们在操作java中的对象，或者修改java中对象之间的关系的时候，ORM 框架能够把我们对对象的修改转换为数据库中表的修改。
</p>

<p>
所以，我们需要在 java 中设置类之间的相互关系，那么，ORM 框架（hibernate）才能够正确的进行这种转换。
</p>

<p>
即，hibernate 会根据我们设置的 ManyToOne 等设置，生成正确的表跟表之间的关联。还能够在我们增删改查的时候，根据我们的设置，生成正确的 sql 语句。
</p>

<p>
所以，不管通过xml还是annotation的形式，你要告诉 hibernate 类之间的关系，他才能在你调用类似 session.save(对象) 的方法时，生成正确的语句并插入数据库。
</p>

<p>
目前为止，先模仿，后理解。练习越多，越明白。只看不练，空把式。
</p>
</div>
</section>


<section id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">ManyToOne</h2>
<div class="outline-text-2" id="text-7">
<p>
如果一个实体类拥有一个属性，这个属性是另外一个实体类的引用，
那么就不能简单用 @Basic 注解或者 &lt;property /&gt; 标签去定义这个属性跟数据库中表的字段之间的映射关系。
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#20363;&#22914;&#65292;&#19968;&#26412;&#20070;&#65292;&#32943;&#23450;&#26377;&#19968;&#20010;&#20316;&#32773;&#65292;&#32780; author &#23646;&#24615;&#19981;&#26159;&#19968;&#20010;&#31616;&#21333;&#31867;&#22411;&#65292;&#32780;&#26159;&#19968;&#20010;&#23545;&#35937;&#30340;&#24341;&#29992;&#12290;</span>
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#20070;&#36319;&#20316;&#32773;&#26159;&#19968;&#20010;&#19968;&#23545;&#19968;&#30340;&#20851;&#31995;&#65292;&#20063;&#23601;&#26159;&#19968;&#26412;&#20070;&#65292;&#21482;&#26377;&#19968;&#20010;&#20316;&#32773;</span>
<span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Book</span> <span style="color: #707183;">{</span>
  <span style="color: #0000FF;">private</span> <span style="color: #6434A3;">Author</span> <span style="color: #BA36A5;">author</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
在这种情况之下，我们需要用 @ManyToOne 注解 或者用 &lt;many-to-one /&gt; 标签去定义这个属性跟表字段之间的映射。
</p>


<p>
many-to-one，这个标签的作用是为所在的列，添加一个外键约束。如果不显式指定 column 名字的话，那么默认生成的名字是 属性名_索引的主键名
</p>

<p>
many-to-one 标签内可以设置 lazy=(false|proxy|no-proxy), fetch=(select|join)。
</p>

<p>
lazy 通过设置为 false 或其他，定义是否要进行懒加载。如果设置为 false，不会启用懒加载，否则，则会启用懒加载。
懒加载是通过创建代理对象的形式去实现的，所以需要用到字节码编译的技术。
lazy=proxy，那么当设置为懒加载的属性被调用的时候，才会触发查询操作。
lazy=no-proxy，那么当被调用的时候，未必会去查询，只有当调用的语句中使用到数据库里存的数据的时候，才会真正的去数据库查询。
所以，它是加强版的懒加载。lazy=no-proxy需要额外的字节码增强的设置，否则会跟 proxy 一致。
</p>

<p>
fetch 设置立即加载组织成的查询语句的策略，如果设置为 join，那么会组织成一条 left-join 语句，
如果是 select，那么会组织成若干条独立的查询语句，会查询多次。
</p>
</div>
</section>




<section id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">OneToMany</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">xml 中的配置</h3>
<div class="outline-text-3" id="text-8-1">
<div class="org-src-container">

<pre class="src src-xml">&lt;<span style="color: #000088; background-color: #DEDEDE;">set</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">books</span><span style="color: #008000;">"</span> <span style="color: #BA36A5;">cascade</span>=<span style="color: #008000;">"</span><span style="color: #008000;">save-update</span><span style="color: #008000;">"</span> <span style="color: #BA36A5;">lazy</span>=<span style="color: #008000;">"</span><span style="color: #008000;">extra</span><span style="color: #008000;">"</span> <span style="color: #BA36A5;">fetch</span>=<span style="color: #008000;">"</span><span style="color: #008000;">select</span><span style="color: #008000;">"</span>&gt;
  &lt;<span style="color: #000088; background-color: #DEDEDE;">key</span> <span style="color: #BA36A5;">column</span>=<span style="color: #008000;">"</span><span style="color: #008000;">authorid</span><span style="color: #008000;">"</span>&gt;&lt;/<span style="color: #000088; background-color: #DEDEDE;">key</span>&gt;
  &lt;<span style="color: #000088; background-color: #DEDEDE;">one-to-many</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"</span><span style="color: #008000;">Book</span><span style="color: #008000;">"</span> /&gt;
&lt;/<span style="color: #000088; background-color: #DEDEDE;">set</span>&gt;
</pre>
</div>

<p>
lazy 有下面几个选项： false/true/extra。默认是 true。
</p>
<ul class="org-ul">
<li>如果设置为 false，那么立即加载，加载的方式是多条 select 语句。
</li>
<li>如果设置为 true，会启用懒加载。只有在调用 books 的任何方法时，才会去初始化列表，从而触发从数据库中查询图书列表的请求。
</li>
<li>如果设置为 extra，也会启用懒加载，但是是更加智能化的懒加载。这时候，如果去调用 books.size() 或 books.contains() 等方法时，并不会真正的初始化图书列表。这样能尽可能节省资源。
</li>
</ul>


<p>
fetch 有以下几个选项：
</p>
<ul class="org-ul">
<li>如果设置了 select，那么，查询的是多条 select 语句。这是默认值。
</li>
<li>如果设置了 join，那么 lazy 的设置会无效，会变成立即加载。加载的语句为 left join 方式
</li>
<li>如果设置了 subselect &#x2026;.
<div class="org-src-container">

<pre class="src src-sql"><span style="color: #8D8D84; font-style: italic;">-- &#22914;&#26524;&#26597;&#35810;&#21040;&#22810;&#26465;&#25968;&#25454;&#65292;&#27599;&#26465;&#25968;&#25454;&#20013;&#37117;&#21547;&#26377;&#19968;&#20010;&#19968;&#23545;&#22810;&#30340;&#20851;&#32852;&#25968;&#25454;&#65292;&#37027;&#20040;&#21021;&#22987;&#21270;&#36825;&#20123;&#20851;&#32852;&#25968;&#25454;&#26102;&#65306;</span>

<span style="color: #8D8D84; font-style: italic;">-- &#22914;&#26524;&#35774;&#32622;&#20026; select&#65292;&#37027;&#20040;&#20998;&#21035;&#21457;&#36865;&#19968;&#26465;&#35821;&#21477;&#21435;&#26597;&#35810;&#12290;</span>
<span style="color: #0000FF;">select</span> * <span style="color: #0000FF;">from</span> book books0_ <span style="color: #0000FF;">where</span> books0_.authorid = 4;
<span style="color: #0000FF;">select</span> * <span style="color: #0000FF;">from</span> book books0_ <span style="color: #0000FF;">where</span> books0_.authorid = 1;
<span style="color: #8D8D84; font-style: italic;">-- &#21487;&#33021;&#36824;&#26377;&#24456;&#22810;&#24456;&#22810;&#26465;</span>

<span style="color: #8D8D84; font-style: italic;">-- &#22914;&#26524;&#35774;&#32622;&#20026; subselect&#65292;&#32452;&#32455;&#25104;&#19968;&#26465;&#35821;&#21477;&#21435;&#26597;&#35810;&#12290;&#20250;&#26356;&#21152;&#33410;&#30465;&#36164;&#28304;&#12290;</span>
<span style="color: #0000FF;">select</span> *
  <span style="color: #0000FF;">from</span> book books0_
 <span style="color: #0000FF;">where</span> books0_.authorid <span style="color: #0000FF;">in</span> <span style="color: #707183;">(</span><span style="color: #0000FF;">select</span> author0_.aid <span style="color: #0000FF;">from</span> author author0_<span style="color: #707183;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">注解的形式</h3>
<div class="outline-text-3" id="text-8-2">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #D0372D;">@OneToMany</span><span style="color: #707183;">(</span>cascade=<span style="color: #D0372D;">CascadeType</span>.ALL, fetch=<span style="color: #D0372D;">FetchType</span>.LAZY<span style="color: #707183;">)</span>
<span style="color: #D0372D;">@Fetch</span><span style="color: #707183;">(</span><span style="color: #D0372D;">FetchMode</span>.<span style="color: #6434A3;">JOIN</span><span style="color: #707183;">)</span>
<span style="color: #D0372D;">@JoinColumn</span><span style="color: #707183;">(</span>name=<span style="color: #008000;">"authorid"</span><span style="color: #707183;">)</span>
<span style="color: #0000FF;">private</span> <span style="color: #6434A3;">Set</span><span style="color: #707183;">&lt;</span><span style="color: #6434A3;">Book</span><span style="color: #707183;">&gt;</span> <span style="color: #BA36A5;">books</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">HashSet</span><span style="color: #707183;">&lt;</span><span style="color: #6434A3;">Book</span><span style="color: #707183;">&gt;()</span>;
</pre>
</div>

<p>
必须要注明 @JoinColumn，否则，会生成中间表来存储关联关系。 @JoinColumn 是用来订制生成的外键字段的。
</p>

<p>
通过 cascade 可以设置级联属性；通过 fetch 可以设置是否采用懒加载；通过 @Fetch 注解可以指定查询语句的形式。
</p>

<p>
注解的形式在某种意义上跟 xml 形式是对应的。
</p>
</div>
</div>
</section>


<section id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">One.Many.双向</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">在 xml 中配置</h3>
<div class="outline-text-3" id="text-9-1">
<div class="org-src-container">

<pre class="src src-xml">&lt;<span style="color: #000088; background-color: #DEDEDE;">set</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">books</span><span style="color: #008000;">"</span> <span style="color: #BA36A5;">inverse</span>=<span style="color: #008000;">"</span><span style="color: #008000;">true</span><span style="color: #008000;">"</span>&gt;
  &lt;<span style="color: #000088; background-color: #DEDEDE;">key</span> <span style="color: #BA36A5;">column</span>=<span style="color: #008000;">"</span><span style="color: #008000;">authorid</span><span style="color: #008000;">"</span>&gt;&lt;/<span style="color: #000088; background-color: #DEDEDE;">key</span>&gt;
  &lt;<span style="color: #000088; background-color: #DEDEDE;">one-to-many</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"</span><span style="color: #008000;">Book</span><span style="color: #008000;">"</span> /&gt;
&lt;/<span style="color: #000088; background-color: #DEDEDE;">set</span>&gt;

&lt;<span style="color: #000088; background-color: #DEDEDE;">many-to-one</span> <span style="color: #BA36A5;">name</span>=<span style="color: #008000;">"</span><span style="color: #008000;">author</span><span style="color: #008000;">"</span> <span style="color: #BA36A5;">column</span>=<span style="color: #008000;">"</span><span style="color: #008000;">authorid</span><span style="color: #008000;">"</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"</span><span style="color: #008000;">Author</span><span style="color: #008000;">"</span>&gt;&lt;/<span style="color: #000088; background-color: #DEDEDE;">many-to-one</span>&gt;
</pre>
</div>

<p>
首先，必须要保证 上面的 column 跟下面的 column 要一致，否则，会在创建表的时候，生成重复的字段，产生不必要的问题。
</p>

<p>
其次，要在 set 上面配置 inverse="true"，否则，会在生成语句的时候，产生很多很多的冗余。在一对多双向关系中，一般情况下，要在多的一边设置 inverse。
</p>

<p>
ps：如果设置了 inverse=true，那么会将另一边设为主端，负责关系的维护。
也就是说，当执行 session.save(author) 的时候，不去维护 authorid 的信息；而当执行 session.save(book) 的时候，才去维护 authorid 的信息。
这样，多的一方维护关系，从而减轻了维护成本，提高了效率。（想想习大大跟我们的例子）。
</p>

<p>
还要注意，在保存的时候，要先保存 1 的一方，否则，会产生很多不必要的 update 语句，从而影响效率。
</p>
</div>
</div>


<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">通过注解的方式进行配置</h3>
<div class="outline-text-3" id="text-9-2">
<p>
在双边分别这样配置：
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">@JoinColumn(name="authorid") &#36825;&#20010;&#19981;&#38656;&#35201;&#21435;&#20889;&#65292;&#22240;&#20026; mappedBy &#20250;&#40664;&#35748;&#35302;&#21457;&#22806;&#38190;&#25805;&#20316;</span>
<span style="color: #D0372D;">@OneToMany</span><span style="color: #707183;">(</span>mappedBy=<span style="color: #008000;">"author"</span><span style="color: #707183;">)</span>   <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">author &#23545;&#24212;&#30340;&#26159; book &#37324;&#38754;&#30340; author &#23646;&#24615;</span>
<span style="color: #0000FF;">private</span> <span style="color: #6434A3;">Set</span><span style="color: #707183;">&lt;</span><span style="color: #6434A3;">Book</span><span style="color: #707183;">&gt;</span> <span style="color: #BA36A5;">books</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">HashSet</span><span style="color: #707183;">&lt;</span><span style="color: #6434A3;">Book</span><span style="color: #707183;">&gt;()</span>;


<span style="color: #D0372D;">@ManyToOne</span>
<span style="color: #D0372D;">@JoinColumn</span><span style="color: #707183;">(</span>name=<span style="color: #008000;">"authorid"</span><span style="color: #707183;">)</span>
<span style="color: #0000FF;">private</span> <span style="color: #6434A3;">Author</span> <span style="color: #BA36A5;">author</span>;
</pre>
</div>

<p>
首先，上边跟下边的 JoinColumn 值的名字，需要一致
</p>

<p>
其次，要在 @OneToMany 里面设置 mappedBy 属性，将双方关系的控制权交给另外一边。
</p>

<p>
最后，保存的时候，注意顺序，要先保存 1 的一边。
</p>
</div>
</div>
</section>



<section id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Cascade</h2>
<div class="outline-text-2" id="text-10">
<p>
级联。
在利用 hibernate 对实体类对象进行持久化(如 session.save)的时候，需要保证里面引用的对象已经处于持久化状态。
</p>

<p>
否则，会出现以下异常
</p>
<pre class="example">
org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance before flushing: hibernate.assoc.many2one.Author
</pre>

<p>
解决方案有以下两种：
</p>
<ol class="org-ol">
<li>在保存对象前，对所有引用到的对象先执行持久化操作。
</li>
<li>在实体类中，为这些引用到的对象，设置合适的级联属性。这样的话，hibernate 会在保存对象的时候，自动将引用到的还没有持久化的对象进行持久化。
</li>
</ol>

<p>
级联可以通过注解的形式进行配置，也可以通过 XML 的形式进行配置。
</p>
<pre class="example">
@ManyToOne(cascade=CascadeType.PERSIST)
&lt;many-to-one cascade="save-update" /&gt;
</pre>

<p>
大抵有如下几种：
</p>
<pre class="example">
none：在保存，删除或修改当前对象时，不对其附属对象（关联对象）进行级联操作，它是默认值。 
save-update：在保存，更新当前对象时，级联保存，更新附属对象（临时对象、游离对象）。 
delete：在删除当前对象时，级联删除附属对象。 
all：所有情况下均进行级联操作，即包含 save-update 和 delete 操作
</pre>


<p>
在我们的开发环境中，设置好 cascade 会让我们的代码更整洁，测试更方便。但是，在工业环境中，不建议使用任何 cascade 设置。
</p>
</div>
</section>

<section id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">Fetch</h2>
<div class="outline-text-2" id="text-11">
<p>
注解配置，有两种 FetchType.EAGER/FetchType.Lazy，分别对应立即加载和惰性加载。
</p>
</div>
</section>

<section id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">Roll</h2>
<div class="outline-text-2" id="text-12">
<ol class="org-ol">
<li>query 对象, hql
</li>
<li>Many to one 关系。包括配置，使用
</li>
<li>One to Many 关系。包括配置，使用
</li>
</ol>
</div>
</section>





<section id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">改写 hello，增加 hibernate 支持</h2>
</section>
<section id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">Java 提高</h2>
<div class="outline-text-2" id="text-14">
</div><div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1">日期与时间</h3>
<div class="outline-text-3" id="text-14-1">
</div><div id="outline-container-sec-14-1-1" class="outline-4">
<h4 id="sec-14-1-1">Date 类</h4>
<div class="outline-text-4" id="text-14-1-1">
<p>
这是 java 最开始就有的类，用来处理时间。
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#33719;&#21462;&#24403;&#21069;&#26102;&#38388;</span>
<span style="color: #6434A3;">Date</span> <span style="color: #BA36A5;">now</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">Date</span><span style="color: #707183;">()</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#25171;&#21360;&#26102;&#38388;&#65292;&#26174;&#24335;&#26684;&#24335;&#20026; Thu Nov 03 16:31:56 CST 2016</span>
System.out.println<span style="color: #707183;">(</span>now<span style="color: #707183;">)</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#33719;&#21462;&#26102;&#38388;&#20013;&#30340;&#24180;&#12289;&#26376;&#12289;&#26085;&#31561;</span>
System.out.println<span style="color: #707183;">(</span>now.getYear<span style="color: #7388D6;">()</span><span style="color: #707183;">)</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#27880;&#24847;&#65292;&#36825;&#26679;&#24471;&#21040;&#30340;&#26159;&#19968;&#20010;&#20943;&#21435;&#20102; 1990 &#30340;&#24180;&#20221;&#12290;</span>
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#24471;&#21040;&#20174; 1970 &#24180;&#21040;&#29616;&#22312;&#32463;&#36807;&#30340;&#27627;&#31186;&#25968;</span>
System.out.println<span style="color: #707183;">(</span>now.getTime<span style="color: #7388D6;">()</span><span style="color: #707183;">)</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#25152;&#20197;&#24471;&#21040;&#20004;&#20010;&#26102;&#38388;&#30456;&#24046;&#22810;&#23569;&#19968;&#33324;&#36825;&#26679;&#34920;&#31034;</span>
<span style="color: #6434A3;">long</span> <span style="color: #BA36A5;">duration</span> = date1.getTime<span style="color: #707183;">()</span> - date2.getTime<span style="color: #707183;">()</span>;

<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#24471;&#21040;&#25351;&#23450;&#26085;&#26399;&#30340;&#26102;&#38388;</span>
<span style="color: #6434A3;">Date</span> <span style="color: #BA36A5;">time1</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">Date</span><span style="color: #707183;">(</span>12212221<span style="color: #707183;">)</span>;
<span style="color: #6434A3;">Date</span> <span style="color: #BA36A5;">time2</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">Date</span><span style="color: #707183;">(</span><span style="color: #008000;">"19900202"</span><span style="color: #707183;">)</span>;
<span style="color: #6434A3;">Date</span> <span style="color: #BA36A5;">time3</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">Date</span><span style="color: #707183;">(</span>1990, 1, 14<span style="color: #707183;">)</span>;  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#27880;&#24847;&#65292;&#26376;&#20221;&#20174;0&#24320;&#22987;&#35745;&#31639;&#12290;1&#36825;&#26465;&#35821;&#21477;&#34920;&#31034; 1990&#24180;2&#26376;14&#26085;</span>
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#36890;&#36807; SimpleDateFormat &#30340;&#24418;&#24335;&#24471;&#21040;&#25351;&#23450;&#26684;&#24335;&#30340;&#26085;&#26399;</span>
<span style="color: #6434A3;">Date</span> <span style="color: #BA36A5;">time4</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">SimpleDateFormat</span><span style="color: #707183;">(</span><span style="color: #008000;">"yyyyMMdd"</span><span style="color: #707183;">)</span>.parse<span style="color: #707183;">(</span><span style="color: #008000;">"20050205"</span><span style="color: #707183;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-14-1-2" class="outline-4">
<h4 id="sec-14-1-2">Calendar 类</h4>
<div class="outline-text-4" id="text-14-1-2">
<p>
后来由于 Date 类在处理国际化方面的一些局限，现在推荐用 Calendar 类代替 Date 类。
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#33719;&#21462;&#24403;&#21069;&#26102;&#38388;</span>
<span style="color: #6434A3;">Calendar</span> <span style="color: #BA36A5;">c</span> = Calendar.getInstance<span style="color: #707183;">()</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#36890;&#36807; getTime &#33719;&#24471; Date &#23545;&#35937;&#12290;&#36890;&#36807;&#19979;&#38754;&#35821;&#21477;&#65292;&#25171;&#21360;&#24403;&#21069;&#26102;&#38388;</span>
System.out.println<span style="color: #707183;">(</span>c.getTime<span style="color: #7388D6;">()</span><span style="color: #707183;">)</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#36890;&#36807;&#19979;&#38754;&#35821;&#21477;&#65292;&#33719;&#21462;&#24180;&#26376;&#26085;&#31561;</span>
System.out.println<span style="color: #707183;">(</span>c.get<span style="color: #7388D6;">(</span><span style="color: #D0372D;">Calendar</span>.YEAR<span style="color: #7388D6;">)</span><span style="color: #707183;">)</span>;

<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#36890;&#36807;&#19979;&#38754;&#35821;&#21477;&#65292;&#21021;&#22987;&#21270;&#19968;&#20010;&#20855;&#20307;&#26102;&#38388;</span>
c.set<span style="color: #707183;">(</span>1999, 2, 4<span style="color: #707183;">)</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#25110;&#32773;&#36890;&#36807;&#26102;&#38388;&#31867;&#22411;&#24471;&#21040;</span>
c.setTime<span style="color: #707183;">(</span><span style="color: #0000FF;">new</span> <span style="color: #6434A3;">Date</span><span style="color: #7388D6;">()</span><span style="color: #707183;">)</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#25110;&#32773;&#65292;&#36890;&#36807;&#30452;&#25509;&#23454;&#20363;&#21270;&#19968;&#20010; Calendar &#30340;&#23454;&#29616;&#31867;&#65306;</span>
<span style="color: #6434A3;">Calendar</span> <span style="color: #BA36A5;">cc</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">GregorianCalendar</span><span style="color: #707183;">(</span>1998,3,11<span style="color: #707183;">)</span>;
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#19979;&#38754;&#35821;&#21477;&#24471;&#21040; 1970 &#24180;&#26469;&#30340; long &#20540;</span>
System.out.println<span style="color: #707183;">(</span>cc.getTimeInMillis<span style="color: #707183;">)</span>;
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-14-1-3" class="outline-4">
<h4 id="sec-14-1-3">其它</h4>
<div class="outline-text-4" id="text-14-1-3">
<p>
通过以上代码看以看到，通过 calendar.setTime()/getTime() 方法可以实现 Date/Calendar 对象的转换。
</p>

<p>
另外，为了方便， System 下面有个静态方法，也可以获取 1970 年到现在过了多少毫秒，返回时 long 值：、
</p>
<pre class="example">
System.currentTimeMillis();
</pre>
<p>
这个非常常用。
</p>
</div>
</div>
</div>



<div id="outline-container-sec-14-2" class="outline-3">
<h3 id="sec-14-2">getter 代码，实现更好的封装</h3>
<div class="outline-text-3" id="text-14-2">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #D0372D;">@Test</span>
<span style="color: #0000FF;">public</span> <span style="color: #6434A3;">void</span> <span style="color: #006699;">testGetterDate</span><span style="color: #707183;">()</span> <span style="color: #0000FF;">throws</span> <span style="color: #6434A3;">Exception</span> <span style="color: #707183;">{</span>
  <span style="color: #6434A3;">Author</span> <span style="color: #BA36A5;">author</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">Author</span><span style="color: #7388D6;">()</span>;
  author.setName<span style="color: #7388D6;">(</span><span style="color: #008000;">"&#24352;&#19977;"</span><span style="color: #7388D6;">)</span>;
  author.setBirth<span style="color: #7388D6;">(</span><span style="color: #0000FF;">new</span> <span style="color: #6434A3;">SimpleDateFormat</span><span style="color: #909183;">(</span><span style="color: #008000;">"yyyy-MM-dd"</span><span style="color: #909183;">)</span>.parse<span style="color: #909183;">(</span><span style="color: #008000;">"1993-04-14"</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span>;

  System.out.println<span style="color: #7388D6;">(</span><span style="color: #008000;">"&#29992;&#25143;&#21019;&#24314;&#25104;&#21151;&#12290;"</span><span style="color: #7388D6;">)</span>;

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#25509;&#19979;&#26469;&#33719;&#21462;&#24180;&#40836;&#65292;&#26377;&#22914;&#19979;&#26041;&#24335;&#65306;</span>

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#31532;&#19968;&#31181;&#20889;&#27861;&#65306;</span>
  System.out.println<span style="color: #7388D6;">(</span><span style="color: #008000;">"1. &#24180;&#40836;&#65306;"</span> + <span style="color: #909183;">(</span><span style="color: #0000FF;">new</span> <span style="color: #6434A3;">Date</span><span style="color: #709870;">()</span>.getYear<span style="color: #709870;">()</span> - author.getBirth<span style="color: #709870;">()</span>.getYear<span style="color: #709870;">()</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span>;

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#31532;&#20108;&#31181;&#26041;&#27861;&#65292;&#21019;&#24314;&#19968;&#20010;&#38745;&#24577;&#26041;&#27861;&#65292;&#36890;&#36807;&#35843;&#29992;&#65292;&#33719;&#21462;&#24180;&#40836;&#65306;</span>
  System.out.println<span style="color: #7388D6;">(</span><span style="color: #008000;">"2. &#24180;&#40836;&#65306;"</span> + BirthUtil.calAge<span style="color: #909183;">(</span>author.getBirth<span style="color: #709870;">()</span><span style="color: #909183;">)</span><span style="color: #7388D6;">)</span>;

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#31532;&#19977;&#31181;&#65292;&#22312; author &#31867;&#20013;&#65292;&#22686;&#21152;&#24180;&#40836;&#23383;&#27573;&#12290;&#22240;&#20026;&#24180;&#40836;&#20063;&#26159;&#20154;&#30340;&#19968;&#20010;&#23646;&#24615;&#12290;</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#36825;&#26679;&#33021;&#26356;&#22909;&#30340;&#20307;&#29616;&#38754;&#21521;&#23545;&#35937;&#30340;&#24605;&#24819;&#65306;&#23553;&#35013;&#12290;</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#22240;&#20026;&#24180;&#40836;&#36319;&#29983;&#26085;&#26377;&#20851;&#31995;&#65292;&#25152;&#20197;&#19981;&#38656;&#35201;&#26174;&#24335;&#36171;&#20540;&#65292;&#22914;&#26524;&#24819;&#33719;&#21462;&#65292;&#37027;&#20040;&#36890;&#36807;&#19979;&#38754;&#30340;&#26041;&#24335;&#65306;</span>
  System.out.println<span style="color: #7388D6;">(</span><span style="color: #008000;">"3. &#24180;&#40836;&#65306;"</span> + author.getAge<span style="color: #909183;">()</span><span style="color: #7388D6;">)</span>;
<span style="color: #707183;">}</span>


<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#22312; getter &#26041;&#27861;&#20013;&#65292;&#21487;&#20197;&#20889;&#19968;&#20123;&#20855;&#20307;&#30340;&#36923;&#36753;&#12290;</span>
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#36825;&#37324;&#36890;&#36807;&#29983;&#26085;&#30340;&#23383;&#27573;&#65292;&#35745;&#31639;&#24180;&#40836;&#12290;&#24403;&#35843;&#29992;&#36825;&#20010; getter &#26041;&#27861;&#30340;&#26102;&#20505;&#65292;&#25165;&#24320;&#22987;&#35745;&#31639;&#12290;</span>
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#32780;&#24180;&#40836;&#36825;&#20010;&#20540;&#65292;&#19981;&#38656;&#35201;&#20445;&#23384;&#21040;&#25968;&#25454;&#24211;&#20013;&#12290;&#25152;&#20197;&#19978;&#38754;&#38656;&#35201;&#22686;&#21152;&#19968;&#20010; @Transient &#27880;&#35299;&#65292;&#23558;&#20854;&#25490;&#20986;&#22312;&#22806;&#12290;</span>
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#36825;&#31181;&#22788;&#29702;&#26041;&#24335;&#65292;&#26159;&#38750;&#24120;&#24120;&#35265;&#30340;&#12290;&#23588;&#20854;&#22312; getter/setter &#26041;&#27861;&#20013;&#65292;&#28155;&#21152;&#33258;&#24049;&#30340;&#36923;&#36753;&#65292;&#26377;&#26102;&#20505;&#65292;&#20250;&#20351;&#20195;&#30721;&#21464;&#24471;&#20415;&#25463;&#12290;</span>
<span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Author</span> <span style="color: #707183;">{</span>
  <span style="color: #0000FF;">private</span> <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">age</span>;
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">... others</span>
  <span style="color: #0000FF;">public</span> <span style="color: #6434A3;">int</span> <span style="color: #006699;">getAge</span><span style="color: #7388D6;">()</span> <span style="color: #7388D6;">{</span>
    <span style="color: #0000FF;">return</span> age == 0 ? BirthUtil.calAge<span style="color: #909183;">(</span>birth<span style="color: #909183;">)</span> : age;
  <span style="color: #7388D6;">}</span>
<span style="color: #707183;">}</span>


<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#26681;&#25454;&#29983;&#26085;&#35745;&#31639;&#24180;&#40836;&#30340;&#38745;&#24577;&#26041;&#27861;</span>
<span style="color: #0000FF;">class</span> <span style="color: #6434A3;">BirthUtil</span> <span style="color: #707183;">{</span>
  <span style="color: #0000FF;">public</span> <span style="color: #0000FF;">static</span> <span style="color: #6434A3;">int</span> <span style="color: #006699;">calAge</span><span style="color: #7388D6;">(</span><span style="color: #6434A3;">Date</span> <span style="color: #BA36A5;">birth</span><span style="color: #7388D6;">)</span> <span style="color: #7388D6;">{</span>
    <span style="color: #6434A3;">Calendar</span> <span style="color: #BA36A5;">cal</span> = Calendar.getInstance<span style="color: #909183;">()</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">now</span> = cal.get<span style="color: #909183;">(</span><span style="color: #D0372D;">Calendar</span>.YEAR<span style="color: #909183;">)</span>;
    cal.setTime<span style="color: #909183;">(</span>birth<span style="color: #909183;">)</span>;
    <span style="color: #0000FF;">return</span> now - cal.get<span style="color: #909183;">(</span><span style="color: #D0372D;">Calendar</span>.YEAR<span style="color: #909183;">)</span>;
  <span style="color: #7388D6;">}</span>
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>
</section>
</div>
<div id="postamble" class="status">
<p class="author">Author: imfine</p>
<p class="date">Created: 2016-11-10 周四 06:39</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation">Go ahead, never stop.</p>
</div>
</body>
</html>
